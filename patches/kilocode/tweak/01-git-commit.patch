file src/services/commit-message/CommitMessageGenerator.ts
label export class CommitMessageGenerator {

 	}
 
 	async generateMessage(params: GenerateMessageParams): Promise<string> {
-		const { gitContext, onProgress } = params
+		const { gitContext, additionalInstructions, onProgress } = params
 
 		try {
 			onProgress?.({
 				message: "Generating commit message...",
 				percentage: 75,
 			})
 
-			const generatedMessage = await this.callAIForCommitMessage(gitContext, onProgress)
+			const generatedMessage = await this.callAIForCommitMessage(gitContext, additionalInstructions, onProgress)
 
 			this.previousGitContext = gitContext
 			this.previousCommitMessage = generatedMessage

label export class CommitMessageGenerator {

 	}
 
 	async buildPrompt(gitContext: string, options: PromptOptions): Promise<string> {
-		const { customSupportPrompts = {}, previousContext, previousMessage } = options
+		const { customSupportPrompts = {}, previousContext, previousMessage, additionalInstructions } = options
 
 		const customInstructions = await addCustomInstructions("", "", "", "commit", {
 			language: "en",
 			localRulesToggleState: undefined,
 			globalRulesToggleState: undefined,
 		})
 
 		const shouldGenerateDifferentMessage =
 			(previousContext === gitContext || this.previousGitContext === gitContext) &&
 			(previousMessage !== null || this.previousCommitMessage !== null)
 
 		const targetPreviousMessage = previousMessage || this.previousCommitMessage
 
+		let instructionContext = ""
+		if (additionalInstructions && additionalInstructions.trim() !== "") {
+			const isPreviousMessage = additionalInstructions.trim() === targetPreviousMessage?.trim()
+			if (!isPreviousMessage) instructionContext = additionalInstructions
+		}
+
 		if (shouldGenerateDifferentMessage && targetPreviousMessage) {
 			const differentMessagePrefix = `# CRITICAL INSTRUCTION: GENERATE A COMPLETELY DIFFERENT COMMIT MESSAGE
 The user has requested a new commit message for the same changes.

label FINAL REMINDER: Your message MUST be COMPLETELY DIFFERENT from the previous mess

 				{
 					gitContext,
 					customInstructions: customInstructions || "",
+					additionalInstructions: instructionContext,
 				},
 				{
 					...customSupportPrompts,
 					COMMIT_MESSAGE: modifiedTemplate,
 				},
 			)
 		} else {
 			return supportPrompt.create(
 				"COMMIT_MESSAGE",
 				{
 					gitContext,
 					customInstructions: customInstructions || "",
+					additionalInstructions: instructionContext,
 				},
 				customSupportPrompts,
 			)
 		}
 	}
 
 	private async callAIForCommitMessage(
 		gitContextString: string,
+		additionalInstructions?: string,
 		onProgress?: (progress: ProgressUpdate) => void,
 	): Promise<string> {
 		const contextProxy = ContextProxy.instance

label FINAL REMINDER: Your message MUST be COMPLETELY DIFFERENT from the previous mess

 			Object.entries(customSupportPrompts).filter(([_, value]) => value !== undefined),
 		) as Record<string, string>
 
-		const prompt = await this.buildPrompt(gitContextString, { customSupportPrompts: filteredPrompts })
+		const prompt = await this.buildPrompt(gitContextString, {
+			customSupportPrompts: filteredPrompts,
+			additionalInstructions,
+		})
 
 		onProgress?.({
 			message: "Calling AI service...",

file src/services/commit-message/CommitMessageOrchestrator.ts
label export class CommitMessageOrchestrator {

 
 			integration.reportProgress?.(70, t("kilocode:commitMessage.generating"))
 
+			const additionalInstructions = await integration.getCommitInputValue?.()
+
 			const message = await messageGenerator.generateMessage({
 				workspacePath: request.workspacePath,
 				selectedFiles: resolution.files,
 				gitContext,
+				additionalInstructions,
 				onProgress: (update) => {
 					if (update.percentage !== undefined) {
 						// Scale AI generation progress to fit within 70-95% range

file src/services/commit-message/adapters/ICommitMessageIntegration.ts
label export interface ICommitMessageIntegration {

 	 */
 	showMessage?(message: string, type: "info" | "error" | "warning"): Promise<void>
 
+	/**
+	 * Get the current value from the IDE's commit input box.
+	 */
+	getCommitInputValue(): Promise<string | undefined>
+
 	/**
 	 * Handle the final result (e.g., set commit message in input box)
 	 */

file src/services/commit-message/adapters/VSCodeCommitMessageAdapter.ts
label export class VSCodeCommitMessageAdapter implements ICommitMessageAdapter {

 							await method(message)
 						},
 
+						getCommitInputValue: async () => {
+							return this.targetRepository?.inputBox.value
+						},
+
 						handleResult: async (result: CommitMessageResult) => {
 							if (result.message && this.targetRepository) {
 								this.targetRepository.inputBox.value = result.message

file src/services/commit-message/types/core.ts
label export interface GenerateMessageParams {

 	workspacePath: string
 	selectedFiles: string[]
 	gitContext: string
+	additionalInstructions?: string
 	onProgress?: (progress: ProgressUpdate) => void
 }
 
 export interface PromptOptions {
 	customSupportPrompts?: Record<string, string>
 	previousContext?: string
 	previousMessage?: string
+	additionalInstructions?: string
 }
 
 export interface ProgressUpdate {

file src/shared/support-prompt.ts
label Requirements:

 	},
 	// kilocode_change start
 	COMMIT_MESSAGE: {
-		template: `# Conventional Commit Message Generator
-## System Instructions
-You are an expert Git commit message generator that creates conventional commit messages based on staged changes. Analyze the provided git diff output and generate appropriate conventional commit messages following the specification.
-
-\${customInstructions}
-
-## CRITICAL: Commit Message Output Rules
-- DO NOT include any internal status indicators or bracketed metadata (e.g. "[Status: Active]", "[Context: Missing]")
-- DO NOT include any task-specific formatting or artifacts from other rules
-- ONLY Generate a clean conventional commit message as specified below
-
-\${gitContext}
-
-## Conventional Commits Format
-Generate commit messages following this exact structure:
-\`\`\`
-<type>[optional scope]: <description>
-[optional body]
-[optional footer(s)]
-\`\`\`
-
-### Core Types (Required)
-- **feat**: New feature or functionality (MINOR version bump)
-- **fix**: Bug fix or error correction (PATCH version bump)
-
-### Additional Types (Extended)
-- **docs**: Documentation changes only
-- **style**: Code style changes (whitespace, formatting, semicolons, etc.)
-- **refactor**: Code refactoring without feature changes or bug fixes
-- **perf**: Performance improvements
-- **test**: Adding or fixing tests
-- **build**: Build system or external dependency changes
-- **ci**: CI/CD configuration changes
-- **chore**: Maintenance tasks, tooling changes
-- **revert**: Reverting previous commits
-
-### Scope Guidelines
-- Use parentheses: \`feat(api):\`, \`fix(ui):\`
-- Common scopes: \`api\`, \`ui\`, \`auth\`, \`db\`, \`config\`, \`deps\`, \`docs\`
-- For monorepos: package or module names
-- Keep scope concise and lowercase
-
-### Description Rules
-- Use imperative mood ("add" not "added" or "adds")
-- Start with lowercase letter
-- No period at the end
-- Maximum 50 characters
-- Be concise but descriptive
-
-### Body Guidelines (Optional)
-- Start one blank line after description
-- Explain the "what" and "why", not the "how"
-- Wrap at 72 characters per line
-- Use for complex changes requiring explanation
-
-### Footer Guidelines (Optional)
-- Start one blank line after body
-- **Breaking Changes**: \`BREAKING CHANGE: description\`
-
-## Analysis Instructions
-When analyzing staged changes:
-1. Determine Primary Type based on the nature of changes
-2. Identify Scope from modified directories or modules
-3. Craft Description focusing on the most significant change
-4. Determine if there are Breaking Changes
-5. For complex changes, include a detailed body explaining what and why
-6. Add appropriate footers for issue references or breaking changes
-
-For significant changes, include a detailed body explaining the changes.
-
-Return ONLY the commit message in the conventional format, nothing else.`,
-	},
+			template: `Perform a mandatory and thorough audit of the entire \`git diff\` to synthesize a single, fully compliant Conventional Commit 1.0.0 message. If BREAKING CHANGES are detected, you shall add a \`!\` character immediately after the type or scope (e.g., \`type(scope)!:\`) to mark the breaking change in the header. The output should be extremely concise, unified, and enclosed in a code block, following the logical structure defined below without deviation.
+	
+	\`\`\`
+	feat(core)!: add multi-factor authentication support
+	
+	- Remove reading and parsing of existing \`manifest.json\`.
+	- Update cookbook to use \`upsert\` method for recipe management.
+	- Adjust \`prepare\` script to run only \`husky\` without building.
+	
+	BREAKING CHANGE: remove the \`login\` endpoint, migrate to OAuth2.
+	\`\`\`
+	
+	Additional mandatory instructions: "\${additionalInstructions}".
+	
+	\${gitContext}`,
+		},
 	// kilocode_change end
 } as const
 
