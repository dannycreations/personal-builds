file cli/docs/PROVIDER_CONFIGURATION.md
label This guide provides detailed information on how to configure each provider in Ki

     - [DeepInfra](#deepinfra)
     - [IO Intelligence](#io-intelligence)
     - [Qwen Code](#qwen-code)
+    - [Gemini CLI](#gemini-cli)
     - [ZAI](#zai)
     - [Minimax](#minimax)
     - [Unbound](#unbound)
 
 ---
 
+### gemini-cli
+
+Gemini CLI integration.
+
+**Description**: Use Google's Gemini models through CLI with OAuth authentication.
+
+**Required Fields**:
+
+- `geminiCliOAuthPath` (text): Path to OAuth credentials file (default: `~/.gemini/oauth_creds.json`)
+- `geminiCliProjectId` (text): Google Cloud project ID
+- `apiModelId` (text): The model to use (default: `gemini-2.5-flash-preview-04-17`)
+
+**Example Configuration**:
+
+```json
+{
+	"id": "default",
+	"provider": "gemini-cli",
+	"geminiCliOAuthPath": "~/.gemini/oauth_creds.json",
+	"geminiCliProjectId": "my-project-123",
+	"apiModelId": "gemini-2.5-flash-preview-04-17"
+}
+```
+
+**Default Model**: `gemini-2.5-flash-preview-04-17`
+
+**Notes**:
+
+- Requires OAuth credentials file
+- Requires Google Cloud project
+
+---
+
 ### zai
 
 ZAI AI platform.

file cli/src/commands/__tests__/models-api.test.ts
label describe("models-api command", () => {

 			"featherless",
 			"roo",
 			"claude-code",
+			"gemini-cli",
 		]
 
 		it.each(staticProviders)("should recognize %s as static provider", (provider) => {

file cli/src/config/mapper.ts
label export function getModelIdForProvider(provider: ProviderConfig): string {

 		case "bedrock":
 		case "vertex":
 		case "gemini":
+		case "gemini-cli":
 		case "mistral":
 		case "moonshot":
 		case "minimax":

file cli/src/config/schema.json

 						"deepinfra",
 						"io-intelligence",
 						"qwen-code",
+						"gemini-cli",
 						"zai",
 						"minimax",
 						"unbound",
 						}
 					}
 				},
+				{
+					"if": {
+						"properties": { "provider": { "const": "gemini-cli" } }
+					},
+					"then": {
+						"properties": {
+							"geminiCliOAuthPath": {
+								"type": "string",
+								"description": "Gemini CLI OAuth path"
+							},
+							"geminiCliProjectId": {
+								"type": "string",
+								"description": "Gemini CLI project ID"
+							},
+							"apiModelId": {
+								"type": "string",
+								"description": "Gemini CLI model ID"
+							}
+						}
+					}
+				},
 				{
 					"if": {
 						"properties": {
 						}
 					}
 				},
+				{
+					"if": {
+						"properties": {
+							"provider": { "const": "gemini-cli" },
+							"geminiCliOAuthPath": { "type": "string", "minLength": 1 }
+						},
+						"required": ["geminiCliOAuthPath"]
+					},
+					"then": {
+						"properties": {
+							"geminiCliOAuthPath": { "minLength": 1 }
+						}
+					}
+				},
+				{
+					"if": {
+						"properties": {
+							"provider": { "const": "gemini-cli" },
+							"geminiCliProjectId": { "type": "string", "minLength": 1 }
+						},
+						"required": ["geminiCliProjectId"]
+					},
+					"then": {
+						"properties": {
+							"geminiCliProjectId": { "minLength": 1 }
+						}
+					}
+				},
+				{
+					"if": {
+						"properties": {
+							"provider": { "const": "gemini-cli" },
+							"apiModelId": { "type": "string", "minLength": 1 }
+						},
+						"required": ["apiModelId"]
+					},
+					"then": {
+						"properties": {
+							"apiModelId": { "minLength": 1 }
+						}
+					}
+				},
 				{
 					"if": {
 						"properties": { "provider": { "const": "zai" } }

file cli/src/config/types.ts
label export {

 	bedrockProviderSchema,
 	vertexProviderSchema,
 	geminiProviderSchema,
+	geminiCliProviderSchema,
 	mistralProviderSchema,
 	moonshotProviderSchema,
 	minimaxProviderSchema,

label export {

 	type BedrockProviderConfig,
 	type VertexProviderConfig,
 	type GeminiProviderConfig,
+	type GeminiCliProviderConfig,
 	type MistralProviderConfig,
 	type MoonshotProviderConfig,
 	type MinimaxProviderConfig,

file cli/src/constants/providers/__tests__/models.test.ts
label describe("Static Provider Models", () => {

 			"fireworks",
 			"featherless",
 			"claude-code",
+			"gemini-cli",
 		]
 
 		it.each(staticProviders)("should return non-empty models for %s provider", (provider) => {

file cli/src/constants/providers/labels.ts
label export const PROVIDER_LABELS: Record<ProviderName, string> = {

 	deepinfra: "DeepInfra",
 	"io-intelligence": "IO Intelligence",
 	"qwen-code": "Qwen Code",
+	"gemini-cli": "Gemini CLI",
 	zai: "Zai",
 	minimax: "MiniMax",
 	unbound: "Unbound",

file cli/src/constants/providers/models.ts
label import {

 	rooDefaultModelId,
 	claudeCodeModels,
 	claudeCodeDefaultModelId,
+	geminiCliModels,
+	geminiCliDefaultModelId,
 	minimaxModels,
 	minimaxDefaultModelId,
 	ovhCloudAiEndpointsDefaultModelId,

label export const PROVIDER_TO_ROUTER_NAME: Record<ProviderName, RouterName | null> =

 	featherless: null,
 	roo: null,
 	"claude-code": null,
+	"gemini-cli": null,
 	"virtual-quota-fallback": null,
 	huggingface: null,
 	inception: null,

label export const PROVIDER_MODEL_FIELD: Record<ProviderName, string | null> = {

 	featherless: null,
 	roo: null,
 	"claude-code": null,
+	"gemini-cli": null,
 	"virtual-quota-fallback": null,
 	huggingface: null,
 	inception: "inceptionLabsModelId",

label export const DEFAULT_MODEL_IDS: Partial<Record<ProviderName, string>> = {

 	minimax: "MiniMax-M2",
 	zai: internationalZAiDefaultModelId,
 	roo: rooDefaultModelId,
+	"gemini-cli": geminiCliDefaultModelId,
 	ovhcloud: ovhCloudAiEndpointsDefaultModelId,
 }
 

label export function getModelsByProvider(params: {
 
 				models: claudeCodeModels as ModelRecord,
 				defaultModel: claudeCodeDefaultModelId,
 			}
+		case "gemini-cli":
+			return {
+				models: geminiCliModels as ModelRecord,
+				defaultModel: geminiCliDefaultModelId,
+			}
 		default:
 			// For providers without static models (e.g., vscode-lm, fake-ai, virtual-quota-fallback)
 			return {

file cli/src/constants/providers/settings.ts
label export const FIELD_REGISTRY: Record<string, FieldMetadata> = {

 		placeholder: "Enter OAuth credentials path...",
 	},
 
+	// Gemini CLI fields
+	geminiCliOAuthPath: {
+		label: "OAuth Credentials Path",
+		type: "text",
+		placeholder: "Enter OAuth credentials path...",
+	},
+	geminiCliProjectId: {
+		label: "Project ID",
+		type: "text",
+		placeholder: "Enter project ID...",
+	},
+
 	// ZAI fields
 	zaiApiKey: {
 		label: "API Key",

label export const getProviderSettings = (provider: ProviderName, config: ProviderSett

 		case "qwen-code":
 			return [createFieldConfig("qwenCodeOauthPath", config, "~/.qwen/oauth_creds.json")]
 
+		case "gemini-cli":
+			return [
+				createFieldConfig("geminiCliOAuthPath", config, "~/.gemini/oauth_creds.json"),
+				createFieldConfig("geminiCliProjectId", config),
+			]
+
 		case "zai":
 			return [
 				createFieldConfig("zaiApiKey", config),

label export const PROVIDER_DEFAULT_MODELS: Record<ProviderName, string> = {

 	deepinfra: "meta-llama/Meta-Llama-3.1-70B-Instruct",
 	"io-intelligence": "gpt-4o",
 	"qwen-code": "qwen-coder-plus-latest",
+	"gemini-cli": "gemini-2.5-flash",
 	zai: "gpt-4o",
 	unbound: "gpt-4o",
 	requesty: "gpt-4o",

file cli/src/constants/providers/validation.ts
label export const PROVIDER_REQUIRED_FIELDS: Record<ProviderName, string[]> = {

 	deepinfra: ["deepInfraApiKey", "deepInfraModelId"],
 	"io-intelligence": ["ioIntelligenceApiKey", "ioIntelligenceModelId"],
 	"qwen-code": ["qwenCodeOauthPath", "apiModelId"],
+	"gemini-cli": ["geminiCliOAuthPath", "geminiCliProjectId", "apiModelId"],
 	zai: ["zaiApiKey", "zaiApiLine", "apiModelId"],
 	unbound: ["unboundApiKey", "unboundModelId"],
 	requesty: ["requestyApiKey", "requestyModelId"],

file packages/core-schemas/src/config/provider.ts
label export const geminiProviderSchema = baseProviderSchema.extend({

 	enableGrounding: z.boolean().optional(),
 })
 
+// Gemini CLI provider
+export const geminiCliProviderSchema = baseProviderSchema.extend({
+	provider: z.literal("gemini-cli"),
+	apiModelId: z.string().optional(),
+	geminiCliOAuthPath: z.string().optional(),
+	geminiCliProjectId: z.string().optional(),
+})
+
 // Mistral provider
 export const mistralProviderSchema = baseProviderSchema.extend({
 	provider: z.literal("mistral"),

label export const providerConfigSchema = z.discriminatedUnion("provider", [

 	bedrockProviderSchema,
 	vertexProviderSchema,
 	geminiProviderSchema,
+	geminiCliProviderSchema,
 	mistralProviderSchema,
 	moonshotProviderSchema,
 	minimaxProviderSchema,

label export type InceptionProviderConfig = z.infer<typeof inceptionProviderSchema>

 export type BedrockProviderConfig = z.infer<typeof bedrockProviderSchema>
 export type VertexProviderConfig = z.infer<typeof vertexProviderSchema>
 export type GeminiProviderConfig = z.infer<typeof geminiProviderSchema>
+export type GeminiCliProviderConfig = z.infer<typeof geminiCliProviderSchema>
 export type MistralProviderConfig = z.infer<typeof mistralProviderSchema>
 export type MoonshotProviderConfig = z.infer<typeof moonshotProviderSchema>
 export type MinimaxProviderConfig = z.infer<typeof minimaxProviderSchema>

file packages/types/src/provider-settings.ts
label export const providerNames = [

 	"featherless",
 	"fireworks",
 	"gemini",
+	"gemini-cli",
 	"groq",
 	"mistral",
 	"moonshot",
 	"minimax",
 	"openai-codex",
 	"openai-native",
 	"openai-responses", // kilocode_change
 	"qwen-code",
 	"roo",
 	// kilocode_change start
 	"kilocode",
 	"minimax",
+	"gemini-cli",
 	"virtual-quota-fallback",
 	"synthetic",
 	"inception",

label const geminiSchema = apiModelIdProviderModelSchema.extend({

 	enableGrounding: z.boolean().optional(),
 })
 
+// kilocode_change start
+const geminiCliSchema = apiModelIdProviderModelSchema.extend({
+	geminiCliOAuthPath: z.string().optional(),
+	geminiCliProjectId: z.string().optional(),
+})
+// kilocode_change end
+
 const openAiCodexSchema = apiModelIdProviderModelSchema.extend({
 	// No additional settings needed - uses OAuth authentication
 })

label export const providerSettingsSchemaDiscriminated = z.discriminatedUnion("apiProv

 	fakeAiSchema.merge(z.object({ apiProvider: z.literal("fake-ai") })),
 	xaiSchema.merge(z.object({ apiProvider: z.literal("xai") })),
 	// kilocode_change start
+	geminiCliSchema.merge(z.object({ apiProvider: z.literal("gemini-cli") })),
 	kilocodeSchema.merge(z.object({ apiProvider: z.literal("kilocode") })),
 	virtualQuotaFallbackSchema.merge(z.object({ apiProvider: z.literal("virtual-quota-fallback") })),
 	syntheticSchema.merge(z.object({ apiProvider: z.literal("synthetic") })),

label export const providerSettingsSchema = z.object({

 	...lmStudioSchema.shape,
 	...geminiSchema.shape,
 	// kilocode_change start
+	...geminiCliSchema.shape,
 	...kilocodeSchema.shape,
 	...virtualQuotaFallbackSchema.shape,
 	...syntheticSchema.shape,

label export const modelIdKeysByProvider: Record<TypicalProvider, ModelIdKey> = {

 	ollama: "ollamaModelId",
 	lmstudio: "lmStudioModelId",
 	gemini: "apiModelId",
+	"gemini-cli": "apiModelId",
 	mistral: "apiModelId",
 	moonshot: "apiModelId",
 	minimax: "apiModelId",
  */
 
label export const MODELS_BY_PROVIDER: Record<
-	Exclude<ProviderName, "fake-ai" | "human-relay" | "openai" | "gemini">,
+	Exclude<ProviderName, "fake-ai" | "human-relay" | "gemini-cli" | "openai" | "gemini">,
 	{ id: ProviderName; label: string; models: string[] }
 > = {
 	anthropic: {

file packages/types/src/providers/gemini-cli.ts

+// kilocode_change new file
+import type { ModelInfo } from "../model.js"
+
+// Gemini CLI models with free tier pricing (all $0)
+export type GeminiCliModelId = keyof typeof geminiCliModels
+
+export const geminiCliDefaultModelId: GeminiCliModelId = "gemini-2.5-flash"
+
+export const geminiCliModels = {
+	"gemini-3-pro-preview": {
+		maxTokens: 64_000,
+		contextWindow: 1_048_576,
+		supportsImages: true,
+		supportsPromptCache: false,
+		inputPrice: 0,
+		outputPrice: 0,
+		supportsReasoningBudget: true,
+		maxThinkingTokens: 32_768,
+	},
+	"gemini-3-flash-preview": {
+		maxTokens: 64_000,
+		contextWindow: 1_048_576,
+		supportsImages: true,
+		supportsPromptCache: false,
+		inputPrice: 0,
+		outputPrice: 0,
+		supportsReasoningBudget: true,
+		maxThinkingTokens: 32_768,
+	},
+	"gemini-2.5-pro": {
+		maxTokens: 64_000,
+		contextWindow: 1_048_576,
+		supportsImages: true,
+		supportsPromptCache: false,
+		inputPrice: 0,
+		outputPrice: 0,
+		maxThinkingTokens: 32_768,
+		supportsReasoningBudget: true,
+		requiredReasoningBudget: true,
+	},
+	"gemini-2.5-flash": {
+		maxTokens: 64_000,
+		contextWindow: 1_048_576,
+		supportsImages: true,
+		supportsPromptCache: false,
+		inputPrice: 0,
+		outputPrice: 0,
+		maxThinkingTokens: 24_576,
+		supportsReasoningBudget: true,
+	},
+} as const satisfies Record<string, ModelInfo>

file packages/types/src/providers/index.ts
label export * from "./featherless.js"

 export * from "./fireworks.js"
 export * from "./gemini.js"
 // kilocode_change start
+export * from "./gemini-cli.js"
 export * from "./ovhcloud.js"
 export * from "./synthetic.js"
 export * from "./inception.js"

label export function getProviderDefaultModelId(

 		case "vercel-ai-gateway":
 			return vercelAiGatewayDefaultModelId
 		case "anthropic":
+		case "gemini-cli":
 		case "human-relay":
 		case "fake-ai":
 		default:

file src/api/index.ts
label export function buildApiHandler(configuration: ProviderSettings): ApiHandler {

 		// kilocode_change start
 		case "kilocode":
 			return new KilocodeOpenrouterHandler(options)
+		case "gemini-cli":
+			return new GeminiCliHandler(options)
 		case "virtual-quota-fallback":
 			return new VirtualQuotaFallbackHandler(options)
 		// kilocode_change end
 		case "baseten":
 			return new BasetenHandler(options)
 		default:
-			apiProvider satisfies undefined
+			apiProvider satisfies "gemini-cli" | undefined
 			return new AnthropicHandler(options)
 	}
 }

file src/api/providers/__tests__/gemini-cli.spec.ts

+// npx vitest run src/api/providers/__tests__/gemini-cli.spec.ts
+
+import { describe, it, expect, vi, beforeEach, afterEach } from "vitest"
+import axios from "axios"
+import type { ApiHandlerOptions } from "../../../shared/api"
+import { GeminiCliHandler } from "../gemini-cli"
+
+// Mock axios
+vi.mock("axios", () => ({
+	default: {
+		get: vi.fn(),
+	},
+}))
+const mockAxios = vi.mocked(axios)
+
+// Mock fs/promises
+vi.mock("fs/promises", () => ({
+	readFile: vi.fn(),
+	writeFile: vi.fn(),
+}))
+
+// Mock google-auth-library
+vi.mock("google-auth-library", () => ({
+	OAuth2Client: vi.fn().mockImplementation(() => ({
+		setCredentials: vi.fn(),
+		refreshAccessToken: vi.fn(),
+		request: vi.fn(),
+	})),
+}))
+
+// Mock dotenvx
+vi.mock("@dotenvx/dotenvx", () => ({
+	config: vi.fn().mockReturnValue({ parsed: null, error: null }),
+}))
+
+describe("GeminiCliHandler", () => {
+	let handler: GeminiCliHandler
+	let mockOptions: ApiHandlerOptions
+
+	beforeEach(() => {
+		vi.clearAllMocks()
+
+		mockOptions = {
+			apiModelId: "gemini-2.5-flash",
+			geminiCliOAuthPath: undefined,
+			geminiCliProjectId: undefined,
+		}
+	})
+
+	afterEach(() => {
+		vi.restoreAllMocks()
+	})
+
+	describe("OAuth Config Fetching", () => {
+		it("should initialize without fetching config immediately", () => {
+			// Act
+			handler = new GeminiCliHandler(mockOptions)
+
+			// Assert - config should not be fetched during construction
+			expect(mockAxios.get).not.toHaveBeenCalled()
+			expect(handler["oauthClientId"]).toBeNull()
+			expect(handler["oauthClientSecret"]).toBeNull()
+		})
+
+		it("should fetch OAuth config from API endpoint when fetchOAuthConfig is called", async () => {
+			// Arrange
+			const mockConfig = {
+				geminiCli: {
+					oauthClientId: "test-client-id",
+					oauthClientSecret: "test-client-secret",
+				},
+			}
+
+			;(mockAxios.get as any).mockResolvedValueOnce({ data: mockConfig })
+			handler = new GeminiCliHandler(mockOptions)
+
+			// Act
+			await handler["fetchOAuthConfig"]()
+
+			// Assert
+			expect(mockAxios.get).toHaveBeenCalledWith("https://api.kilo.ai/extension-config.json")
+			expect(handler["oauthClientId"]).toBe("test-client-id")
+			expect(handler["oauthClientSecret"]).toBe("test-client-secret")
+		})
+
+		it("should throw error if OAuth config fetch fails", async () => {
+			// Arrange
+			const mockError = new Error("Network error")
+			;(mockAxios.get as any).mockRejectedValueOnce(mockError)
+			handler = new GeminiCliHandler(mockOptions)
+
+			// Act & Assert
+			await expect(handler["fetchOAuthConfig"]()).rejects.toThrow()
+		})
+	})
+
+	// The loadOAuthCredentials integration with fetchOAuthConfig is tested through actual usage
+	// Individual components (fetchOAuthConfig) are tested above
+})

file src/api/providers/gemini-cli.ts

+import type { Anthropic } from "@anthropic-ai/sdk"
+import { OAuth2Client } from "google-auth-library"
+import * as fs from "fs/promises"
+import * as path from "path"
+import * as os from "os"
+import axios from "axios"
+import dotenvx from "@dotenvx/dotenvx"
+
+import { type ModelInfo, type GeminiCliModelId, geminiCliDefaultModelId, geminiCliModels } from "@roo-code/types"
+
+import type { ApiHandlerOptions } from "../../shared/api"
+import { t } from "../../i18n"
+
+import { convertAnthropicContentToGemini, convertAnthropicMessageToGemini } from "../transform/gemini-format"
+import type { ApiStream } from "../transform/stream"
+import { getModelParams } from "../transform/model-params"
+
+import type { SingleCompletionHandler, ApiHandlerCreateMessageMetadata } from "../index"
+import { BaseProvider } from "./base-provider"
+import { getExtensionConfigUrl } from "@roo-code/types"
+
+// OAuth2 Configuration (from Cline implementation)
+const OAUTH_REDIRECT_URI = "http://localhost:45289"
+
+// Code Assist API Configuration
+const CODE_ASSIST_ENDPOINT = "https://cloudcode-pa.googleapis.com"
+const CODE_ASSIST_API_VERSION = "v1internal"
+
+interface OAuthCredentials {
+	access_token: string
+	refresh_token: string
+	token_type: string
+	expiry_date: number
+}
+
+interface OauthConfig {
+	oauthClientId: string
+	oauthClientSecret: string
+}
+
+export class GeminiCliHandler extends BaseProvider implements SingleCompletionHandler {
+	protected options: ApiHandlerOptions
+	private authClient: OAuth2Client
+	private projectId: string | null = null
+	private credentials: OAuthCredentials | null = null
+	private oauthClientId: string | null = null
+	private oauthClientSecret: string | null = null
+
+	constructor(options: ApiHandlerOptions) {
+		super()
+		this.options = options
+
+		// Initialize OAuth2 client (will be set up after fetching config)
+		this.authClient = new OAuth2Client("", "", OAUTH_REDIRECT_URI)
+	}
+
+	private async fetchOAuthConfig(): Promise<void> {
+		try {
+			const response = await axios.get<{ geminiCli: OauthConfig }>(getExtensionConfigUrl())
+			const config = response.data
+
+			this.oauthClientId = config.geminiCli.oauthClientId
+			this.oauthClientSecret = config.geminiCli.oauthClientSecret
+
+			this.authClient = new OAuth2Client(this.oauthClientId, this.oauthClientSecret, OAUTH_REDIRECT_URI)
+		} catch (error) {
+			throw new Error("OAuth client credentials not found in config", error)
+		}
+	}
+
+	private async loadOAuthCredentials(): Promise<void> {
+		try {
+			// First, fetch OAuth config if not already fetched
+			if (!this.oauthClientId || !this.oauthClientSecret) {
+				await this.fetchOAuthConfig()
+			}
+
+			const credPath = this.options.geminiCliOAuthPath || path.join(os.homedir(), ".gemini", "oauth_creds.json")
+			const credData = await fs.readFile(credPath, "utf-8")
+			this.credentials = JSON.parse(credData)
+
+			// Set credentials on the OAuth2 client
+			if (this.credentials) {
+				this.authClient.setCredentials({
+					access_token: this.credentials.access_token,
+					refresh_token: this.credentials.refresh_token,
+					expiry_date: this.credentials.expiry_date,
+				})
+			}
+		} catch (error) {
+			throw new Error(t("common:errors.geminiCli.oauthLoadFailed", { error }))
+		}
+	}
+
+	private async ensureAuthenticated(): Promise<void> {
+		if (!this.credentials) {
+			await this.loadOAuthCredentials()
+		}
+
+		// Check if token needs refresh
+		if (this.credentials && this.credentials.expiry_date < Date.now()) {
+			try {
+				const { credentials } = await this.authClient.refreshAccessToken()
+				if (credentials.access_token) {
+					this.credentials = {
+						access_token: credentials.access_token!,
+						refresh_token: credentials.refresh_token || this.credentials.refresh_token,
+						token_type: credentials.token_type || "Bearer",
+						expiry_date: credentials.expiry_date || Date.now() + 3600 * 1000,
+					}
+					// Optionally save refreshed credentials back to file
+					const credPath =
+						this.options.geminiCliOAuthPath || path.join(os.homedir(), ".gemini", "oauth_creds.json")
+					await fs.writeFile(credPath, JSON.stringify(this.credentials, null, 2))
+				}
+			} catch (error) {
+				throw new Error(t("common:errors.geminiCli.tokenRefreshFailed", { error }))
+			}
+		}
+	}
+
+	/**
+	 * Call a Code Assist API endpoint
+	 */
+	private async callEndpoint(method: string, body: any, retryAuth: boolean = true): Promise<any> {
+		try {
+			const res = await this.authClient.request({
+				url: `${CODE_ASSIST_ENDPOINT}/${CODE_ASSIST_API_VERSION}:${method}`,
+				method: "POST",
+				headers: {
+					"Content-Type": "application/json",
+				},
+				responseType: "json",
+				data: JSON.stringify(body),
+			})
+			return res.data
+		} catch (error: any) {
+			console.error(`[GeminiCLI] Error calling ${method}:`, error)
+			console.error(`[GeminiCLI] Error response:`, error.response?.data)
+			console.error(`[GeminiCLI] Error status:`, error.response?.status)
+			console.error(`[GeminiCLI] Error message:`, error.message)
+
+			// If we get a 401 and haven't retried yet, try refreshing auth
+			if (error.response?.status === 401 && retryAuth) {
+				await this.ensureAuthenticated() // This will refresh the token
+				return this.callEndpoint(method, body, false) // Retry without further auth retries
+			}
+
+			throw error
+		}
+	}
+
+	/**
+	 * Discover or retrieve the project ID
+	 */
+	private async discoverProjectId(): Promise<string> {
+		// If we already have a project ID, use it
+		if (this.options.geminiCliProjectId) {
+			this.projectId = this.options.geminiCliProjectId
+			return this.projectId
+		}
+
+		// If we've already discovered it, return it
+		if (this.projectId) {
+			return this.projectId
+		}
+
+		// Lookup for the project id from the env variable
+		// with a fallback to a default project ID (can be anything for personal OAuth)
+		const envPath = this.options.geminiCliOAuthPath
+			? path.join(path.dirname(this.options.geminiCliOAuthPath), ".env")
+			: path.join(os.homedir(), ".gemini", ".env")
+
+		const { parsed, error } = dotenvx.config({ path: envPath, override: true })
+
+		if (error) {
+			console.warn("[GeminiCLI] .env file not found or invalid format, proceeding with default project ID")
+		}
+
+		// If the project ID was in the .env file, use it and return early.
+		if (parsed?.GOOGLE_CLOUD_PROJECT) {
+			this.projectId = parsed.GOOGLE_CLOUD_PROJECT
+			return this.projectId
+		}
+
+		const initialProjectId = process.env.GOOGLE_CLOUD_PROJECT ?? "" // kilocode_change
+
+		// Prepare client metadata
+		const clientMetadata = {
+			ideType: "IDE_UNSPECIFIED",
+			platform: "PLATFORM_UNSPECIFIED",
+			pluginType: "GEMINI",
+			duetProject: initialProjectId,
+		}
+
+		try {
+			// Call loadCodeAssist to discover the actual project ID
+			const loadRequest = {
+				cloudaicompanionProject: initialProjectId,
+				metadata: clientMetadata,
+			}
+
+			const loadResponse = await this.callEndpoint("loadCodeAssist", loadRequest)
+
+			// Check if we already have a project ID from the response
+			if (loadResponse.cloudaicompanionProject) {
+				this.projectId = loadResponse.cloudaicompanionProject
+				return this.projectId as string
+			}
+
+			// If no existing project, we need to onboard
+			const defaultTier = loadResponse.allowedTiers?.find((tier: any) => tier.isDefault)
+			const tierId = defaultTier?.id || "free-tier"
+
+			const onboardRequest = {
+				tierId: tierId,
+				cloudaicompanionProject: initialProjectId,
+				metadata: clientMetadata,
+			}
+
+			let lroResponse = await this.callEndpoint("onboardUser", onboardRequest)
+
+			// Poll until operation is complete with timeout protection
+			const MAX_RETRIES = 30 // Maximum number of retries (60 seconds total)
+			let retryCount = 0
+
+			while (!lroResponse.done && retryCount < MAX_RETRIES) {
+				await new Promise((resolve) => setTimeout(resolve, 2000))
+				lroResponse = await this.callEndpoint("onboardUser", onboardRequest)
+				retryCount++
+			}
+
+			if (!lroResponse.done) {
+				throw new Error(t("common:errors.geminiCli.onboardingTimeout"))
+			}
+
+			const discoveredProjectId = lroResponse.response?.cloudaicompanionProject?.id || initialProjectId
+			this.projectId = discoveredProjectId
+			return this.projectId as string
+		} catch (error: any) {
+			console.error("Failed to discover project ID:", error.response?.data || error.message)
+			throw new Error(t("common:errors.geminiCli.projectDiscoveryFailed"))
+		}
+	}
+
+	/**
+	 * Parse Server-Sent Events from a stream
+	 */
+	private async *parseSSEStream(stream: NodeJS.ReadableStream): AsyncGenerator<any> {
+		let buffer = ""
+
+		for await (const chunk of stream) {
+			buffer += chunk.toString()
+			const lines = buffer.split("\n")
+			buffer = lines.pop() || ""
+
+			for (const line of lines) {
+				if (line.startsWith("data: ")) {
+					const data = line.slice(6).trim()
+					if (data === "[DONE]") continue
+
+					try {
+						const parsed = JSON.parse(data)
+						yield parsed
+					} catch (e) {
+						console.error("Error parsing SSE data:", e)
+					}
+				}
+			}
+		}
+	}
+
+	async *createMessage(
+		systemInstruction: string,
+		messages: Anthropic.Messages.MessageParam[],
+		metadata?: ApiHandlerCreateMessageMetadata,
+	): ApiStream {
+		await this.ensureAuthenticated()
+		const projectId = await this.discoverProjectId()
+
+		const { id: model, info, reasoning: thinkingConfig, maxTokens } = this.getModel()
+
+		// Convert messages to Gemini format
+		const contents = messages.map((message) => convertAnthropicMessageToGemini(message))
+
+		// Prepare request body for Code Assist API - matching Cline's structure
+		const requestBody: any = {
+			model: model,
+			project: projectId,
+			request: {
+				contents: [
+					{
+						role: "user",
+						parts: [{ text: systemInstruction }],
+					},
+					...contents,
+				],
+				generationConfig: {
+					temperature: this.options.modelTemperature ?? 0.7,
+					maxOutputTokens: this.options.modelMaxTokens ?? maxTokens ?? 8192,
+				},
+			},
+		}
+
+		// Add thinking config if applicable
+		if (thinkingConfig) {
+			requestBody.request.generationConfig.thinkingConfig = thinkingConfig
+		}
+
+		try {
+			// Call Code Assist streaming endpoint using OAuth2Client
+			const response = await this.authClient.request({
+				url: `${CODE_ASSIST_ENDPOINT}/${CODE_ASSIST_API_VERSION}:streamGenerateContent`,
+				method: "POST",
+				params: { alt: "sse" },
+				headers: {
+					"Content-Type": "application/json",
+				},
+				responseType: "stream",
+				data: JSON.stringify(requestBody),
+			})
+
+			// Process the SSE stream
+			let lastUsageMetadata: any = undefined
+
+			for await (const jsonData of this.parseSSEStream(response.data as NodeJS.ReadableStream)) {
+				// Extract content from the response
+				const responseData = jsonData.response || jsonData
+				const candidate = responseData.candidates?.[0]
+
+				if (candidate?.content?.parts) {
+					for (const part of candidate.content.parts) {
+						if (part.text) {
+							// Check if this is a thinking/reasoning part
+							if (part.thought === true) {
+								yield {
+									type: "reasoning",
+									text: part.text,
+								}
+							} else {
+								yield {
+									type: "text",
+									text: part.text,
+								}
+							}
+						}
+					}
+				}
+
+				// Store usage metadata for final reporting
+				if (responseData.usageMetadata) {
+					lastUsageMetadata = responseData.usageMetadata
+				}
+
+				// Check if this is the final chunk
+				if (candidate?.finishReason) {
+					break
+				}
+			}
+
+			// Yield final usage information
+			if (lastUsageMetadata) {
+				const inputTokens = lastUsageMetadata.promptTokenCount ?? 0
+				const outputTokens = lastUsageMetadata.candidatesTokenCount ?? 0
+				const cacheReadTokens = lastUsageMetadata.cachedContentTokenCount
+				const reasoningTokens = lastUsageMetadata.thoughtsTokenCount
+
+				yield {
+					type: "usage",
+					inputTokens,
+					outputTokens,
+					cacheReadTokens,
+					reasoningTokens,
+					totalCost: 0, // Free tier - all costs are 0
+				}
+			}
+		} catch (error: any) {
+			console.error("[GeminiCLI] API Error:", error.response?.status, error.response?.statusText)
+			console.error("[GeminiCLI] Error Response:", error.response?.data)
+
+			if (error.response?.status === 429) {
+				throw new Error(t("common:errors.geminiCli.rateLimitExceeded"))
+			}
+			if (error.response?.status === 400) {
+				throw new Error(
+					t("common:errors.geminiCli.badRequest", {
+						details: JSON.stringify(error.response?.data) || error.message,
+					}),
+				)
+			}
+			throw new Error(t("common:errors.geminiCli.apiError", { error: error.message }))
+		}
+	}
+
+	override getModel() {
+		const modelId = this.options.apiModelId
+		// Handle :thinking suffix before checking if model exists
+		const baseModelId = modelId?.endsWith(":thinking") ? modelId.replace(":thinking", "") : modelId
+		let id =
+			baseModelId && baseModelId in geminiCliModels ? (baseModelId as GeminiCliModelId) : geminiCliDefaultModelId
+		const info: ModelInfo = geminiCliModels[id]
+		const params = getModelParams({ format: "gemini", modelId: id, model: info, settings: this.options })
+
+		// Return the cleaned model ID
+		return { id, info, ...params }
+	}
+
+	async completePrompt(prompt: string): Promise<string> {
+		await this.ensureAuthenticated()
+		const projectId = await this.discoverProjectId()
+
+		try {
+			const { id: model } = this.getModel()
+
+			const requestBody = {
+				model: model,
+				project: projectId,
+				request: {
+					contents: [{ role: "user", parts: [{ text: prompt }] }],
+					generationConfig: {
+						temperature: this.options.modelTemperature ?? 0.7,
+					},
+				},
+			}
+
+			const response = await this.authClient.request({
+				url: `${CODE_ASSIST_ENDPOINT}/${CODE_ASSIST_API_VERSION}:generateContent`,
+				method: "POST",
+				headers: {
+					"Content-Type": "application/json",
+				},
+				data: JSON.stringify(requestBody),
+			})
+
+			// Extract text from response, handling both direct and nested response structures
+			const rawData = response.data as any
+			const responseData = rawData.response || rawData
+
+			if (responseData.candidates && responseData.candidates.length > 0) {
+				const candidate = responseData.candidates[0]
+				if (candidate.content && candidate.content.parts) {
+					const textParts = candidate.content.parts
+						.filter((part: any) => part.text && !part.thought)
+						.map((part: any) => part.text)
+						.join("")
+					return textParts
+				}
+			}
+
+			return ""
+		} catch (error) {
+			if (error instanceof Error) {
+				throw new Error(t("common:errors.geminiCli.completionError", { error: error.message }))
+			}
+			throw error
+		}
+	}
+
+	override async countTokens(content: Array<Anthropic.Messages.ContentBlockParam>): Promise<number> {
+		// For OAuth/free tier, we can't use the token counting API
+		// Fall back to the base provider's tiktoken implementation
+		return super.countTokens(content)
+	}
+}

file src/api/providers/index.ts
label export { UnboundHandler } from "./unbound"

 export { VertexHandler } from "./vertex"
 // kilocode_change start
 export { OVHcloudAIEndpointsHandler } from "./ovhcloud"
+export { GeminiCliHandler } from "./gemini-cli"
 export { VirtualQuotaFallbackHandler } from "./virtual-quota-fallback"
 export { SyntheticHandler } from "./synthetic"
 export { InceptionLabsHandler } from "./inception"

file src/i18n/locales/ar/common.json

 			"apiKeyModelPlanMismatch": "مفاتيح API وخطط الاشتراك تدعم نماذج مختلفة. تأكد إن النموذج المحدد داخل ضمن خطتك.",
 			"notFound": "ملف Claude Code التنفيذي '{{claudePath}}' غير موجود.\n\nرجاءً ثبت Claude Code CLI:\n1. زر {{installationUrl}} لتحميل Claude Code\n2. اتبع تعليمات التثبيت لنظام التشغيل\n3. تأكد إن أمر 'claude' متاح في PATH\n4. أو اضبط مسار مخصص في إعدادات Kilo Code تحت 'مسار Claude Code'\n\nالخطأ الأصلي: {{originalError}}"
 		},
+		"geminiCli": {
+			"oauthLoadFailed": "فشل تحميل بيانات OAuth. لازم تسوي تسجيل دخول أول: {{error}}",
+			"tokenRefreshFailed": "فشل تحديث رمز OAuth: {{error}}",
+			"onboardingTimeout": "انتهى وقت التهيئة بعد ٦٠ ثانية. حاول مرة ثانية.",
+			"projectDiscoveryFailed": "ما قدرنا نكتشف معرف المشروع. تأكد إنك سجلت دخول بـ 'gemini auth'.",
+			"rateLimitExceeded": "تجاوزت الحد المسموح. الحد المجاني تم استهلاكه.",
+			"badRequest": "طلب غير صحيح: {{details}}",
+			"apiError": "خطأ من Gemini CLI: {{error}}",
+			"completionError": "خطأ أثناء الإكمال في Gemini CLI: {{error}}"
+		},
 		"qwenCode": {
 			"oauthLoadFailed": "فشل تحميل بيانات OAuth. لازم تسوي مصادقة أول: {{error}}"
 		},

file src/i18n/locales/ca/common.json

 			"stoppedWithReason": "Claude Code s'ha aturat per la raó: {{reason}}",
 			"apiKeyModelPlanMismatch": "Les claus API i els plans de subscripció permeten models diferents. Assegura't que el model seleccionat estigui inclòs al teu pla."
 		},
+		"geminiCli": {
+			"oauthLoadFailed": "No s'han pogut carregar les credencials OAuth. Si us plau, autentica't primer: {{error}}",
+			"tokenRefreshFailed": "No s'ha pogut actualitzar el token OAuth: {{error}}",
+			"onboardingTimeout": "L'operació d'onboarding ha esgotat el temps després de 60 segons. Si us plau, torna-ho a provar més tard.",
+			"projectDiscoveryFailed": "No s'ha pogut descobrir l'ID del projecte. Assegura't d'estar autenticat amb 'gemini auth'.",
+			"rateLimitExceeded": "S'ha superat el límit de velocitat. S'han assolit els límits del nivell gratuït.",
+			"badRequest": "Sol·licitud incorrecta: {{details}}",
+			"apiError": "Error de l'API Gemini CLI: {{error}}",
+			"completionError": "Error de compleció de Gemini CLI: {{error}}"
+		},
 		"message": {
 			"no_active_task_to_delete": "No hi ha cap tasca activa de la qual eliminar missatges",
 			"invalid_timestamp_for_deletion": "Marca de temps del missatge no vàlida per a l'eliminació",

file src/i18n/locales/cs/common.json

 			"apiKeyModelPlanMismatch": "API klíče a plány předplatného umožňují různé modely. Ujisti se, že vybraný model je zahrnut v tvém plánu.",
 			"notFound": "Spustitelný soubor Claude Code '{{claudePath}}' nebyl nalezen.\n\nNainstalujte prosím Claude Code CLI:\n1. Navštivte {{installationUrl}} pro stažení Claude Code\n2. Postupujte podle pokynů pro instalaci pro váš operační systém\n3. Ujistěte se, že příkaz 'claude' je dostupný v PATH\n4. Alternativně nakonfigurujte vlastní cestu v nastavení Kilo Code pod 'Cesta Claude Code'\n\nPůvodní chyba: {{originalError}}"
 		},
+		"geminiCli": {
+			"oauthLoadFailed": "Nepodařilo se načíst OAuth přihlašovací údaje. Nejprve se prosím autentizujte: {{error}}",
+			"tokenRefreshFailed": "Nepodařilo se obnovit OAuth token: {{error}}",
+			"onboardingTimeout": "Onboarding operace vypršela po 60 sekundách. Zkuste to prosím později.",
+			"projectDiscoveryFailed": "Nepodařilo se objevit ID projektu. Ujistěte se, že jste autentizováni pomocí 'gemini auth'.",
+			"rateLimitExceeded": "Překročen limit rychlosti. Limity bezplatné úrovně byly dosaženy.",
+			"badRequest": "Špatný požadavek: {{details}}",
+			"apiError": "Chyba Gemini CLI API: {{error}}",
+			"completionError": "Chyba dokončení Gemini CLI: {{error}}"
+		},
 		"qwenCode": {
 			"oauthLoadFailed": "Nepodařilo se načíst OAuth přihlašovací údaje. Nejprve se prosím autentizujte: {{error}}"
 		},

file src/i18n/locales/de/common.json

 			"stoppedWithReason": "Claude Code wurde mit Grund gestoppt: {{reason}}",
 			"apiKeyModelPlanMismatch": "API-Schlüssel und Abonnement-Pläne erlauben verschiedene Modelle. Stelle sicher, dass das ausgewählte Modell in deinem Plan enthalten ist."
 		},
+		"geminiCli": {
+			"oauthLoadFailed": "Fehler beim Laden der OAuth-Anmeldedaten. Bitte authentifiziere dich zuerst: {{error}}",
+			"tokenRefreshFailed": "Fehler beim Aktualisieren des OAuth-Tokens: {{error}}",
+			"onboardingTimeout": "Onboarding-Vorgang nach 60 Sekunden abgebrochen. Bitte versuche es später erneut.",
+			"projectDiscoveryFailed": "Projekt-ID konnte nicht ermittelt werden. Stelle sicher, dass du mit 'gemini auth' authentifiziert bist.",
+			"rateLimitExceeded": "Anfragenlimit überschritten. Die Limits des kostenlosen Tarifs wurden erreicht.",
+			"badRequest": "Ungültige Anfrage: {{details}}",
+			"apiError": "Gemini CLI API-Fehler: {{error}}",
+			"completionError": "Gemini CLI Vervollständigungsfehler: {{error}}"
+		},
 		"message": {
 			"no_active_task_to_delete": "Keine aktive Aufgabe, aus der Nachrichten gelöscht werden können",
 			"invalid_timestamp_for_deletion": "Ungültiger Nachrichten-Zeitstempel zum Löschen",

file src/i18n/locales/en/common.json

 			"stoppedWithReason": "Claude Code stopped with reason: {{reason}}",
 			"apiKeyModelPlanMismatch": "API keys and subscription plans allow different models. Make sure the selected model is included in your plan."
 		},
+		"geminiCli": {
+			"oauthLoadFailed": "Failed to load OAuth credentials. Please authenticate first: {{error}}",
+			"tokenRefreshFailed": "Failed to refresh OAuth token: {{error}}",
+			"onboardingTimeout": "Onboarding operation timed out after 60 seconds. Please try again later.",
+			"projectDiscoveryFailed": "Could not discover project ID. Make sure you're authenticated with 'gemini auth'.",
+			"rateLimitExceeded": "Rate limit exceeded. Free tier limits have been reached.",
+			"badRequest": "Bad request: {{details}}",
+			"apiError": "Gemini CLI API error: {{error}}",
+			"completionError": "Gemini CLI completion error: {{error}}"
+		},
 		"qwenCode": {
 			"oauthLoadFailed": "Failed to load OAuth credentials. Please authenticate first: {{error}}"
 		},

file src/i18n/locales/es/common.json

 			"stoppedWithReason": "Claude Code se detuvo por la razón: {{reason}}",
 			"apiKeyModelPlanMismatch": "Las claves API y los planes de suscripción permiten diferentes modelos. Asegúrate de que el modelo seleccionado esté incluido en tu plan."
 		},
+		"geminiCli": {
+			"oauthLoadFailed": "Error al cargar credenciales OAuth. Por favor autentícate primero: {{error}}",
+			"tokenRefreshFailed": "Error al actualizar token OAuth: {{error}}",
+			"onboardingTimeout": "La operación de incorporación expiró después de 60 segundos. Inténtalo de nuevo más tarde.",
+			"projectDiscoveryFailed": "No se pudo descubrir el ID del proyecto. Asegúrate de estar autenticado con 'gemini auth'.",
+			"rateLimitExceeded": "Límite de velocidad excedido. Se han alcanzado los límites del nivel gratuito.",
+			"badRequest": "Solicitud incorrecta: {{details}}",
+			"apiError": "Error de API de Gemini CLI: {{error}}",
+			"completionError": "Error de completado de Gemini CLI: {{error}}"
+		},
 		"message": {
 			"no_active_task_to_delete": "No hay tarea activa de la cual eliminar mensajes",
 			"invalid_timestamp_for_deletion": "Marca de tiempo del mensaje no válida para eliminación",

file src/i18n/locales/fr/common.json

 			"stoppedWithReason": "Claude Code s'est arrêté pour la raison : {{reason}}",
 			"apiKeyModelPlanMismatch": "Les clés API et les plans d'abonnement permettent différents modèles. Assurez-vous que le modèle sélectionné est inclus dans votre plan."
 		},
+		"geminiCli": {
+			"oauthLoadFailed": "Échec du chargement des identifiants OAuth. Veuillez vous authentifier d'abord : {{error}}",
+			"tokenRefreshFailed": "Échec du renouvellement du token OAuth : {{error}}",
+			"onboardingTimeout": "L'opération d'intégration a expiré après 60 secondes. Veuillez réessayer plus tard.",
+			"projectDiscoveryFailed": "Impossible de découvrir l'ID du projet. Assurez-vous d'être authentifié avec 'gemini auth'.",
+			"rateLimitExceeded": "Limite de débit dépassée. Les limites du niveau gratuit ont été atteintes.",
+			"badRequest": "Requête incorrecte : {{details}}",
+			"apiError": "Erreur API Gemini CLI : {{error}}",
+			"completionError": "Erreur de complétion Gemini CLI : {{error}}"
+		},
 		"qwenCode": {
 			"oauthLoadFailed": "Échec du chargement des identifiants OAuth. Veuillez vous authentifier d'abord : {{error}}"
 		},

file src/i18n/locales/hi/common.json

 			"stoppedWithReason": "Claude Code इस कारण से रुका: {{reason}}",
 			"apiKeyModelPlanMismatch": "API keys and subscription plans allow different models. Make sure the selected model is included in your plan."
 		},
+		"geminiCli": {
+			"oauthLoadFailed": "OAuth क्रेडेंशियल लोड करने में विफल। कृपया पहले प्रमाणीकरण करें: {{error}}",
+			"tokenRefreshFailed": "OAuth टोकन रीफ्रेश करने में विफल: {{error}}",
+			"onboardingTimeout": "ऑनबोर्डिंग ऑपरेशन 60 सेकंड बाद टाइमआउट हो गया। कृपया बाद में पुनः प्रयास करें।",
+			"projectDiscoveryFailed": "प्रोजेक्ट ID खोजने में असमर्थ। सुनिश्चित करें कि आप 'gemini auth' के साथ प्रमाणित हैं।",
+			"rateLimitExceeded": "दर सीमा पार हो गई। मुफ्त टियर की सीमा पहुंच गई है।",
+			"badRequest": "गलत अनुरोध: {{details}}",
+			"apiError": "Gemini CLI API त्रुटि: {{error}}",
+			"completionError": "Gemini CLI पूर्णता त्रुटि: {{error}}"
+		},
 		"qwenCode": {
 			"oauthLoadFailed": "OAuth क्रेडेंशियल लोड करने में विफल। कृपया पहले प्रमाणीकरण करें: {{error}}"
 		},

file src/i18n/locales/id/common.json

 			"stoppedWithReason": "Claude Code berhenti karena alasan: {{reason}}",
 			"apiKeyModelPlanMismatch": "API keys and subscription plans allow different models. Make sure the selected model is included in your plan."
 		},
+		"geminiCli": {
+			"oauthLoadFailed": "Gagal memuat kredensial OAuth. Silakan autentikasi terlebih dahulu: {{error}}",
+			"tokenRefreshFailed": "Gagal memperbarui token OAuth: {{error}}",
+			"onboardingTimeout": "Operasi onboarding habis waktu setelah 60 detik. Silakan coba lagi nanti.",
+			"projectDiscoveryFailed": "Tidak dapat menemukan ID proyek. Pastikan Anda terautentikasi dengan 'gemini auth'.",
+			"rateLimitExceeded": "Batas kecepatan terlampaui. Batas tingkat gratis telah tercapai.",
+			"badRequest": "Permintaan tidak valid: {{details}}",
+			"apiError": "Kesalahan API Gemini CLI: {{error}}",
+			"completionError": "Kesalahan penyelesaian Gemini CLI: {{error}}"
+		},
 		"qwenCode": {
 			"oauthLoadFailed": "Gagal memuat kredensial OAuth. Silakan autentikasi terlebih dahulu: {{error}}"
 		},

file src/i18n/locales/it/common.json

 			"stoppedWithReason": "Claude Code si è fermato per il motivo: {{reason}}",
 			"apiKeyModelPlanMismatch": "API keys and subscription plans allow different models. Make sure the selected model is included in your plan."
 		},
+		"geminiCli": {
+			"oauthLoadFailed": "Impossibile caricare le credenziali OAuth. Autenticati prima: {{error}}",
+			"tokenRefreshFailed": "Impossibile aggiornare il token OAuth: {{error}}",
+			"onboardingTimeout": "L'operazione di onboarding è scaduta dopo 60 secondi. Riprova più tardi.",
+			"projectDiscoveryFailed": "Impossibile scoprire l'ID del progetto. Assicurati di essere autenticato con 'gemini auth'.",
+			"rateLimitExceeded": "Limite di velocità superato. I limiti del livello gratuito sono stati raggiunti.",
+			"badRequest": "Richiesta non valida: {{details}}",
+			"apiError": "Errore API Gemini CLI: {{error}}",
+			"completionError": "Errore di completamento Gemini CLI: {{error}}"
+		},
 		"message": {
 			"no_active_task_to_delete": "Nessuna attività attiva da cui eliminare messaggi",
 			"invalid_timestamp_for_deletion": "Timestamp del messaggio non valido per l'eliminazione",

file src/i18n/locales/ja/common.json

 			"stoppedWithReason": "Claude Code が理由により停止しました：{{reason}}",
 			"apiKeyModelPlanMismatch": "API keys and subscription plans allow different models. Make sure the selected model is included in your plan."
 		},
+		"geminiCli": {
+			"oauthLoadFailed": "OAuth認証情報の読み込みに失敗しました。まず認証してください: {{error}}",
+			"tokenRefreshFailed": "OAuthトークンの更新に失敗しました: {{error}}",
+			"onboardingTimeout": "オンボーディング操作が60秒でタイムアウトしました。後でもう一度お試しください。",
+			"projectDiscoveryFailed": "プロジェクトIDを発見できませんでした。'gemini auth'で認証されていることを確認してください。",
+			"rateLimitExceeded": "レート制限を超過しました。無料プランの制限に達しています。",
+			"badRequest": "不正なリクエスト: {{details}}",
+			"apiError": "Gemini CLI APIエラー: {{error}}",
+			"completionError": "Gemini CLI補完エラー: {{error}}"
+		},
 		"message": {
 			"no_active_task_to_delete": "メッセージを削除するアクティブなタスクがありません",
 			"invalid_timestamp_for_deletion": "削除用のメッセージタイムスタンプが無効です",

file src/i18n/locales/ko/common.json

 			"stoppedWithReason": "Claude Code가 다음 이유로 중지되었습니다: {{reason}}",
 			"apiKeyModelPlanMismatch": "API keys and subscription plans allow different models. Make sure the selected model is included in your plan."
 		},
+		"geminiCli": {
+			"oauthLoadFailed": "OAuth 자격 증명을 로드하지 못했습니다. 먼저 인증하세요: {{error}}",
+			"tokenRefreshFailed": "OAuth 토큰을 새로 고치지 못했습니다: {{error}}",
+			"onboardingTimeout": "온보딩 작업이 60초 후 시간 초과되었습니다. 나중에 다시 시도하세요.",
+			"projectDiscoveryFailed": "프로젝트 ID를 찾을 수 없습니다. 'gemini auth'로 인증되었는지 확인하세요.",
+			"rateLimitExceeded": "속도 제한을 초과했습니다. 무료 등급 제한에 도달했습니다.",
+			"badRequest": "잘못된 요청: {{details}}",
+			"apiError": "Gemini CLI API 오류: {{error}}",
+			"completionError": "Gemini CLI 완성 오류: {{error}}"
+		},
 		"qwenCode": {
 			"oauthLoadFailed": "OAuth 자격 증명을 로드하지 못했습니다. 먼저 인증하세요: {{error}}"
 		},

file src/i18n/locales/nl/common.json

 			"stoppedWithReason": "Claude Code gestopt om reden: {{reason}}",
 			"apiKeyModelPlanMismatch": "API keys and subscription plans allow different models. Make sure the selected model is included in your plan."
 		},
+		"geminiCli": {
+			"oauthLoadFailed": "Kan OAuth-referenties niet laden. Authenticeer eerst: {{error}}",
+			"tokenRefreshFailed": "Kan OAuth-token niet vernieuwen: {{error}}",
+			"onboardingTimeout": "Onboarding-operatie is na 60 seconden verlopen. Probeer het later opnieuw.",
+			"projectDiscoveryFailed": "Kan project-ID niet ontdekken. Zorg ervoor dat je geauthenticeerd bent met 'gemini auth'.",
+			"rateLimitExceeded": "Snelheidslimiet overschreden. Gratis tier limieten zijn bereikt.",
+			"badRequest": "Ongeldig verzoek: {{details}}",
+			"apiError": "Gemini CLI API-fout: {{error}}",
+			"completionError": "Gemini CLI voltooiingsfout: {{error}}"
+		},
 		"qwenCode": {
 			"oauthLoadFailed": "Kan OAuth-referenties niet laden. Authenticeer eerst: {{error}}"
 		},

file src/i18n/locales/pl/common.json

 			"stoppedWithReason": "Claude Code zatrzymał się z powodu: {{reason}}",
 			"apiKeyModelPlanMismatch": "API keys and subscription plans allow different models. Make sure the selected model is included in your plan."
 		},
+		"geminiCli": {
+			"oauthLoadFailed": "Nie udało się załadować danych uwierzytelniających OAuth. Najpierw się uwierzytelnij: {{error}}",
+			"tokenRefreshFailed": "Nie udało się odświeżyć tokenu OAuth: {{error}}",
+			"onboardingTimeout": "Operacja wdrażania przekroczyła limit czasu po 60 sekundach. Spróbuj ponownie później.",
+			"projectDiscoveryFailed": "Nie można odkryć ID projektu. Upewnij się, że jesteś uwierzytelniony za pomocą 'gemini auth'.",
+			"rateLimitExceeded": "Przekroczono limit szybkości. Osiągnięto limity darmowego poziomu.",
+			"badRequest": "Nieprawidłowe żądanie: {{details}}",
+			"apiError": "Błąd API Gemini CLI: {{error}}",
+			"completionError": "Błąd uzupełniania Gemini CLI: {{error}}"
+		},
 		"message": {
 			"no_active_task_to_delete": "Brak aktywnego zadania do usunięcia wiadomości",
 			"invalid_timestamp_for_deletion": "Nieprawidłowy znacznik czasu wiadomości do usunięcia",

file src/i18n/locales/pt-BR/common.json

 			"stoppedWithReason": "Claude Code parou pela razão: {{reason}}",
 			"apiKeyModelPlanMismatch": "API keys and subscription plans allow different models. Make sure the selected model is included in your plan."
 		},
+		"geminiCli": {
+			"oauthLoadFailed": "Falha ao carregar credenciais OAuth. Por favor, autentique-se primeiro: {{error}}",
+			"tokenRefreshFailed": "Falha ao atualizar token OAuth: {{error}}",
+			"onboardingTimeout": "A operação de integração expirou após 60 segundos. Por favor, tente novamente mais tarde.",
+			"projectDiscoveryFailed": "Não foi possível descobrir o ID do projeto. Certifique-se de estar autenticado com 'gemini auth'.",
+			"rateLimitExceeded": "Limite de taxa excedido. Os limites do nível gratuito foram atingidos.",
+			"badRequest": "Solicitação inválida: {{details}}",
+			"apiError": "Erro da API Gemini CLI: {{error}}",
+			"completionError": "Erro de conclusão do Gemini CLI: {{error}}"
+		},
 		"message": {
 			"no_active_task_to_delete": "Nenhuma tarefa ativa para excluir mensagens",
 			"invalid_timestamp_for_deletion": "Timestamp da mensagem inválido para exclusão",

file src/i18n/locales/ru/common.json

 			"stoppedWithReason": "Claude Code остановился по причине: {{reason}}",
 			"apiKeyModelPlanMismatch": "API keys and subscription plans allow different models. Make sure the selected model is included in your plan."
 		},
+		"geminiCli": {
+			"oauthLoadFailed": "Не удалось загрузить учетные данные OAuth. Сначала выполните аутентификацию: {{error}}",
+			"tokenRefreshFailed": "Не удалось обновить токен OAuth: {{error}}",
+			"onboardingTimeout": "Операция подключения истекла через 60 секунд. Пожалуйста, попробуйте позже.",
+			"projectDiscoveryFailed": "Не удалось обнаружить идентификатор проекта. Убедитесь, что вы аутентифицированы с помощью 'gemini auth'.",
+			"rateLimitExceeded": "Превышен лимит скорости. Достигнуты лимиты бесплатного уровня.",
+			"badRequest": "Неверный запрос: {{details}}",
+			"apiError": "Ошибка API Gemini CLI: {{error}}",
+			"completionError": "Ошибка завершения Gemini CLI: {{error}}"
+		},
 		"message": {
 			"no_active_task_to_delete": "Нет активной задачи для удаления сообщений",
 			"invalid_timestamp_for_deletion": "Недействительная временная метка сообщения для удаления",

file src/i18n/locales/th/common.json

 			"apiKeyModelPlanMismatch": "คีย์ API และแผนการสมัครสมาชิกอนุญาตให้ใช้โมเดลที่แตกต่างกัน ตรวจสอบให้แน่ใจว่าโมเดลที่เลือกรวมอยู่ในแผนของคุณ",
 			"notFound": "ไม่พบไฟล์ปฏิบัติการ Claude Code '{{claudePath}}'\n\nกรุณาติดตั้ง Claude Code CLI:\n1. เยี่ยมชม {{installationUrl}} เพื่อดาวน์โหลด Claude Code\n2. ทำตามคำแนะนำการติดตั้งสำหรับระบบปฏิบัติการของคุณ\n3. ตรวจสอบให้แน่ใจว่าคำสั่ง 'claude' พร้อมใช้งานใน PATH\n4. หรือกำหนดค่าเส้นทางแบบกำหนดเองในการตั้งค่า Kilo Code ภายใต้ 'เส้นทาง Claude Code'\n\nข้อผิดพลาดเดิม: {{originalError}}"
 		},
+		"geminiCli": {
+			"oauthLoadFailed": "ล้มเหลวในการโหลดข้อมูลประจำตัว OAuth กรุณายืนยันตัวตนก่อน: {{error}}",
+			"tokenRefreshFailed": "ล้มเหลวในการรีเฟรช OAuth token: {{error}}",
+			"onboardingTimeout": "การดำเนินการ onboarding หมดเวลาหลังจาก 60 วินาที กรุณาลองอีกครั้งในภายหลัง",
+			"projectDiscoveryFailed": "ไม่สามารถค้นหา project ID ตรวจสอบให้แน่ใจว่าคุณยืนยันตัวตนด้วย 'gemini auth'",
+			"rateLimitExceeded": "เกินขีดจำกัดอัตรา ถึงขีดจำกัดของระดับฟรีแล้ว",
+			"badRequest": "คำขอไม่ถูกต้อง: {{details}}",
+			"apiError": "ข้อผิดพลาด Gemini CLI API: {{error}}",
+			"completionError": "ข้อผิดพลาดการทำงานเสร็จสิ้น Gemini CLI: {{error}}"
+		},
 		"gemini": {
 			"generate_stream": "ข้อผิดพลาดในการสร้างสตรีมบริบท Gemini: {{error}}",
 			"generate_complete_prompt": "ข้อผิดพลาดการทำงานเสร็จสิ้น Gemini: {{error}}",

file src/i18n/locales/tr/common.json

 			"stoppedWithReason": "Claude Code şu nedenle durdu: {{reason}}",
 			"apiKeyModelPlanMismatch": "API keys and subscription plans allow different models. Make sure the selected model is included in your plan."
 		},
+		"geminiCli": {
+			"oauthLoadFailed": "OAuth kimlik bilgileri yüklenemedi. Lütfen önce kimlik doğrulaması yapın: {{error}}",
+			"tokenRefreshFailed": "OAuth token yenilenemedi: {{error}}",
+			"onboardingTimeout": "Onboarding işlemi 60 saniye sonra zaman aşımına uğradı. Lütfen daha sonra tekrar deneyin.",
+			"projectDiscoveryFailed": "Proje ID'si keşfedilemedi. 'gemini auth' ile kimlik doğrulaması yaptığınızdan emin olun.",
+			"rateLimitExceeded": "Hız sınırı aşıldı. Ücretsiz seviye sınırlarına ulaşıldı.",
+			"badRequest": "Geçersiz istek: {{details}}",
+			"apiError": "Gemini CLI API hatası: {{error}}",
+			"completionError": "Gemini CLI tamamlama hatası: {{error}}"
+		},
 		"qwenCode": {
 			"oauthLoadFailed": "OAuth kimlik bilgileri yüklenemedi. Lütfen önce kimlik doğrulaması yapın: {{error}}"
 		},

file src/i18n/locales/uk/common.json

 		"command_already_exists": "Команда \"{{commandName}}\" вже існує",
 		"create_command_failed": "Не вдалося створити команду",
 		"command_template_content": "---\ndescription: \"Короткий опис того, що робить ця команда\"\n---\n\nЦе нова slash команда. Відредагуйте цей файл, щоб налаштувати поведінку команди.",
+		"geminiCli": {
+			"oauthLoadFailed": "Не вдалося завантажити OAuth дані для входу. Будь ласка, спочатку автентифікуйся: {{error}}",
+			"tokenRefreshFailed": "Не вдалося оновити OAuth token: {{error}}",
+			"onboardingTimeout": "Операція onboarding перевищила час очікування після 60 секунд. Будь ласка, спробуй пізніше.",
+			"projectDiscoveryFailed": "Не вдалося знайти ID проекту. Переконайся, що ти автентифікований за допомогою 'gemini auth'.",
+			"rateLimitExceeded": "Перевищено ліміт швидкості. Досягнуто обмежень безкоштовного рівня.",
+			"badRequest": "Неправильний запит: {{details}}",
+			"apiError": "Помилка Gemini CLI API: {{error}}",
+			"completionError": "Помилка завершення Gemini CLI: {{error}}"
+		},
 		"gemini": {
 			"generate_stream": "Помилка генерації контекстного потоку Gemini: {{error}}",
 			"generate_complete_prompt": "Помилка завершення Gemini: {{error}}",

file src/i18n/locales/vi/common.json

 			"stoppedWithReason": "Claude Code dừng lại vì lý do: {{reason}}",
 			"apiKeyModelPlanMismatch": "API keys and subscription plans allow different models. Make sure the selected model is included in your plan."
 		},
+		"geminiCli": {
+			"oauthLoadFailed": "Không thể tải thông tin xác thực OAuth. Vui lòng xác thực trước: {{error}}",
+			"tokenRefreshFailed": "Không thể làm mới token OAuth: {{error}}",
+			"onboardingTimeout": "Thao tác onboarding đã hết thời gian chờ sau 60 giây. Vui lòng thử lại sau.",
+			"projectDiscoveryFailed": "Không thể khám phá ID dự án. Đảm bảo bạn đã xác thực bằng 'gemini auth'.",
+			"rateLimitExceeded": "Đã vượt quá giới hạn tốc độ. Đã đạt đến giới hạn của gói miễn phí.",
+			"badRequest": "Yêu cầu không hợp lệ: {{details}}",
+			"apiError": "Lỗi API Gemini CLI: {{error}}",
+			"completionError": "Lỗi hoàn thành Gemini CLI: {{error}}"
+		},
 		"message": {
 			"no_active_task_to_delete": "Không có nhiệm vụ hoạt động để xóa tin nhắn",
 			"invalid_timestamp_for_deletion": "Dấu thời gian tin nhắn không hợp lệ để xóa",

file src/i18n/locales/zh-CN/common.json

 			"stoppedWithReason": "Claude Code 停止，原因：{{reason}}",
 			"apiKeyModelPlanMismatch": "API keys and subscription plans allow different models. Make sure the selected model is included in your plan."
 		},
+		"geminiCli": {
+			"oauthLoadFailed": "加载 OAuth 凭据失败。请先进行身份验证：{{error}}",
+			"tokenRefreshFailed": "刷新 OAuth Token 失败：{{error}}",
+			"onboardingTimeout": "入门操作在 60 秒后超时。请稍后重试。",
+			"projectDiscoveryFailed": "无法发现项目 ID。请确保已使用 'gemini auth' 进行身份验证。",
+			"rateLimitExceeded": "API 请求频率限制已超出。免费层级限制已达到。",
+			"badRequest": "请求错误：{{details}}",
+			"apiError": "Gemini CLI API 错误：{{error}}",
+			"completionError": "Gemini CLI 补全错误：{{error}}"
+		},
 		"message": {
 			"no_active_task_to_delete": "没有可删除消息的活跃任务",
 			"invalid_timestamp_for_deletion": "删除操作的消息时间戳无效",

file src/i18n/locales/zh-TW/common.json

 			"stoppedWithReason": "Claude Code 停止，原因：{{reason}}",
 			"apiKeyModelPlanMismatch": "API 金鑰和訂閱方案允許不同的模型。請確保所選模型包含在您的方案中。"
 		},
+		"geminiCli": {
+			"oauthLoadFailed": "無法載入 OAuth 憑證。請先進行驗證：{{error}}",
+			"tokenRefreshFailed": "無法重新整理 OAuth 權杖：{{error}}",
+			"onboardingTimeout": "新手導引操作在 60 秒後逾時。請稍後再試。",
+			"projectDiscoveryFailed": "無法發現專案 ID。請確保您已使用 'gemini auth' 進行驗證。",
+			"rateLimitExceeded": "超過速率限制。已達到免費層級限制。",
+			"badRequest": "錯誤的請求：{{details}}",
+			"apiError": "Gemini CLI API 錯誤：{{error}}",
+			"completionError": "Gemini CLI 完成錯誤：{{error}}"
+		},
 		"qwenCode": {
 			"oauthLoadFailed": "無法載入 OAuth 憑證。請先進行驗證：{{error}}"
 		},

file src/shared/checkExistApiConfig.ts
label export function checkExistKey(config: ProviderSettings | undefined) {

 	// Special case for human-relay, fake-ai, claude-code, openai-codex, qwen-code, roo and kilocode providers which don't need any configuration.
 	if (
 		config.apiProvider &&
-		["human-relay", "fake-ai", "claude-code", "openai-codex", "qwen-code", "roo", "kilocode"].includes(
+		["human-relay", "fake-ai", "claude-code", "openai-codex", "qwen-code", "roo", "kilocode", "gemini-cli"].includes(config.apiProvider) // kilocode_change: add kilocode for anonymous access
 	) {
 		return true
 	}

file webview-ui/src/components/kilocode/hooks/useProviderModels.ts
label import {

 	litellmDefaultModelId,
 	qwenCodeModels,
 	qwenCodeDefaultModelId,
+	geminiCliModels,
 	claudeCodeModels,
 	claudeCodeDefaultModelId,
 	doubaoModels,

label export const getModelsByProvider = ({

 				defaultModel: qwenCodeDefaultModelId,
 			}
 		}
+		case "gemini-cli": {
+			return {
+				models: geminiCliModels,
+				defaultModel: geminiDefaultModelId,
+			}
+		}
 		case "anthropic": {
 			return {
 				models: anthropicModels,

file webview-ui/src/components/settings/ApiOptions.tsx
label import {

 	claudeCodeDefaultModelId,
 	qwenCodeDefaultModelId,
 	geminiDefaultModelId,
+	geminiCliDefaultModelId,
 	deepSeekDefaultModelId,
 	moonshotDefaultModelId,
 	// kilocode_change start

label import {

 	VSCodeLM,
 	XAI,
 	// kilocode_change start
+	GeminiCli,
 	VirtualQuotaFallbackProvider,
 	Synthetic,
 	OvhCloudAiEndpoints,

label const ApiOptions = ({

 				lmstudio: { field: "lmStudioModelId" },
 				// kilocode_change start
 				kilocode: { field: "kilocodeModel", default: kilocodeDefaultModel },
+				"gemini-cli": { field: "apiModelId", default: geminiCliDefaultModelId },
 				synthetic: { field: "apiModelId", default: syntheticDefaultModelId },
 				ovhcloud: { field: "ovhCloudAiEndpointsModelId", default: ovhCloudAiEndpointsDefaultModelId },
 				inception: { field: "inceptionLabsModelId", default: inceptionDefaultModelId },
 
label const ApiOptions = ({

 
 		// kilocode_change start
 		// Providers that don't have documentation pages yet
-		const excludedProviders = ["moonshot", "chutes", "cerebras", "litellm", "zai", "qwen-code", "minimax"]
+		const excludedProviders = ["gemini-cli", "moonshot", "chutes", "cerebras", "litellm", "zai", "qwen-code", "minimax"]
 
 		// Skip documentation link when the provider is excluded because documentation is not available
 		if (excludedProviders.includes(selectedProvider)) {

label const ApiOptions = ({

 			)}
 
 			{/* kilocode_change start */}
+			{selectedProvider === "gemini-cli" && (
+				<GeminiCli apiConfiguration={apiConfiguration} setApiConfigurationField={setApiConfigurationField} />
+			)}
+
 			{selectedProvider === "virtual-quota-fallback" && (
 				<VirtualQuotaFallbackProvider
 					apiConfiguration={apiConfiguration}

file webview-ui/src/components/settings/constants.ts
label import {

 	moonshotModels,
 	// kilocode_change start
 	// geminiModels,
+	geminiCliModels,
 	// kilocode_change end
 	mistralModels,
 	openAiNativeModels,

label export const MODELS_BY_PROVIDER: Partial<Record<ProviderName, Record<string, Mod

 	moonshot: moonshotModels,
 	// kilocode_change start
 	// gemini: geminiModels,
+	"gemini-cli": geminiCliModels,
 	// kilocode_change end
 	mistral: mistralModels,
 	"openai-native": openAiNativeModels,

label export const PROVIDERS = [

 	{ value: "doubao", label: "Doubao", proxy: false },
 	// kilocode_change start
 	{ value: "inception", label: "Inception", proxy: false },
+	{ value: "gemini-cli", label: "Gemini CLI", proxy: false },
 	{ value: "virtual-quota-fallback", label: "Virtual Quota Fallback", proxy: false },
 	{ value: "synthetic", label: "Synthetic", proxy: false },
 	{ value: "ovhcloud", label: "OVHcloud AI Endpoints", proxy: false },

file webview-ui/src/components/settings/providers/GeminiCli.tsx

+import { useCallback } from "react"
+import { VSCodeTextField } from "@vscode/webview-ui-toolkit/react"
+
+import type { ProviderSettings } from "@roo-code/types"
+
+import { useAppTranslation } from "@src/i18n/TranslationContext"
+import { VSCodeLink } from "@vscode/webview-ui-toolkit/react"
+
+import { inputEventTransform } from "../transforms"
+
+type GeminiCliProps = {
+	apiConfiguration: ProviderSettings
+	setApiConfigurationField: (field: keyof ProviderSettings, value: ProviderSettings[keyof ProviderSettings]) => void
+}
+
+export const GeminiCli = ({ apiConfiguration, setApiConfigurationField }: GeminiCliProps) => {
+	const { t } = useAppTranslation()
+
+	const handleInputChange = useCallback(
+		<K extends keyof ProviderSettings, E>(
+			field: K,
+			transform: (event: E) => ProviderSettings[K] = inputEventTransform,
+		) =>
+			(event: E | Event) => {
+				setApiConfigurationField(field, transform(event as E))
+			},
+		[setApiConfigurationField],
+	)
+
+	return (
+		<>
+			<VSCodeTextField
+				value={apiConfiguration?.geminiCliOAuthPath || ""}
+				onInput={handleInputChange("geminiCliOAuthPath")}
+				placeholder="~/.gemini/oauth_creds.json"
+				className="w-full">
+				<label className="block font-medium mb-1">{t("settings:providers.geminiCli.oauthPath")}</label>
+			</VSCodeTextField>
+			<div className="text-sm text-vscode-descriptionForeground -mt-2">
+				{t("settings:providers.geminiCli.oauthPathDescription")}
+			</div>
+
+			<div className="text-sm text-vscode-descriptionForeground mt-3">
+				{t("settings:providers.geminiCli.description")}
+			</div>
+
+			<div className="text-sm text-vscode-descriptionForeground mt-2">
+				{t("settings:providers.geminiCli.instructions")}{" "}
+				<code className="text-vscode-textPreformat-foreground">gemini</code>{" "}
+				{t("settings:providers.geminiCli.instructionsContinued")}
+			</div>
+
+			<VSCodeLink
+				href="https://github.com/google-gemini/gemini-cli?tab=readme-ov-file#quickstart"
+				className="text-vscode-textLink-foreground hover:text-vscode-textLink-activeForeground mt-2 inline-block">
+				{t("settings:providers.geminiCli.setupLink")}
+			</VSCodeLink>
+
+			<div className="mt-3 p-3 bg-vscode-editorWidget-background border border-vscode-editorWidget-border rounded">
+				<div className="flex items-center gap-2 mb-2">
+					<i className="codicon codicon-warning text-vscode-notificationsWarningIcon-foreground" />
+					<span className="font-semibold text-sm">{t("settings:providers.geminiCli.requirementsTitle")}</span>
+				</div>
+				<ul className="list-disc list-inside space-y-1 text-sm text-vscode-descriptionForeground">
+					<li>{t("settings:providers.geminiCli.requirement1")}</li>
+					<li>{t("settings:providers.geminiCli.requirement2")}</li>
+					<li>{t("settings:providers.geminiCli.requirement3")}</li>
+					<li>{t("settings:providers.geminiCli.requirement4")}</li>
+					<li>{t("settings:providers.geminiCli.requirement5")}</li>
+				</ul>
+			</div>
+
+			<div className="mt-3 flex items-center gap-2">
+				<i className="codicon codicon-check text-vscode-notificationsInfoIcon-foreground" />
+				<span className="text-sm text-vscode-descriptionForeground">
+					{t("settings:providers.geminiCli.freeAccess")}
+				</span>
+			</div>
+		</>
+	)
+}

file webview-ui/src/components/settings/providers/__tests__/GeminiCli.spec.tsx

+import { render, screen, fireEvent } from "@testing-library/react"
+import { describe, it, expect, vi } from "vitest"
+
+import type { ProviderSettings } from "@roo-code/types"
+
+import { GeminiCli } from "../GeminiCli"
+
+// Mock the translation hook
+vi.mock("@src/i18n/TranslationContext", () => ({
+	useAppTranslation: () => ({
+		t: (key: string) => key,
+	}),
+}))
+
+// Mock VSCodeLink to render as a regular anchor tag
+vi.mock("@vscode/webview-ui-toolkit/react", async () => {
+	const actual = await vi.importActual("@vscode/webview-ui-toolkit/react")
+	return {
+		...actual,
+		VSCodeLink: ({ children, href, ...props }: any) => (
+			<a href={href} {...props}>
+				{children}
+			</a>
+		),
+	}
+})
+
+describe("GeminiCli", () => {
+	const mockSetApiConfigurationField = vi.fn()
+	const defaultProps = {
+		apiConfiguration: {} as ProviderSettings,
+		setApiConfigurationField: mockSetApiConfigurationField,
+	}
+
+	beforeEach(() => {
+		vi.clearAllMocks()
+	})
+
+	it("renders all required elements", () => {
+		render(<GeminiCli {...defaultProps} />)
+
+		// Check for OAuth path input
+		expect(screen.getByText("settings:providers.geminiCli.oauthPath")).toBeInTheDocument()
+		expect(screen.getByPlaceholderText("~/.gemini/oauth_creds.json")).toBeInTheDocument()
+
+		// Check for description text
+		expect(screen.getByText("settings:providers.geminiCli.description")).toBeInTheDocument()
+
+		// Check for instructions - they're in the same div but broken up by the code element
+		// Find all elements that contain the instruction parts
+		const instructionsDivs = screen.getAllByText((_content, element) => {
+			// Check if this element contains all the expected text parts
+			const fullText = element?.textContent || ""
+			return (
+				fullText.includes("settings:providers.geminiCli.instructions") &&
+				fullText.includes("gemini") &&
+				fullText.includes("settings:providers.geminiCli.instructionsContinued")
+			)
+		})
+		// Find the div with the correct classes
+		const instructionsDiv = instructionsDivs.find(
+			(div) =>
+				div.classList.contains("text-sm") &&
+				div.classList.contains("text-vscode-descriptionForeground") &&
+				div.classList.contains("mt-2"),
+		)
+		expect(instructionsDiv).toBeDefined()
+		expect(instructionsDiv).toBeInTheDocument()
+
+		// Also verify the code element exists
+		const codeElement = screen.getByText("gemini")
+		expect(codeElement).toBeInTheDocument()
+		expect(codeElement.tagName).toBe("CODE")
+
+		// Check for setup link
+		expect(screen.getByText("settings:providers.geminiCli.setupLink")).toBeInTheDocument()
+
+		// Check for requirements
+		expect(screen.getByText("settings:providers.geminiCli.requirementsTitle")).toBeInTheDocument()
+		expect(screen.getByText("settings:providers.geminiCli.requirement1")).toBeInTheDocument()
+		expect(screen.getByText("settings:providers.geminiCli.requirement2")).toBeInTheDocument()
+		expect(screen.getByText("settings:providers.geminiCli.requirement3")).toBeInTheDocument()
+		expect(screen.getByText("settings:providers.geminiCli.requirement4")).toBeInTheDocument()
+		expect(screen.getByText("settings:providers.geminiCli.requirement5")).toBeInTheDocument()
+
+		// Check for free access note
+		expect(screen.getByText("settings:providers.geminiCli.freeAccess")).toBeInTheDocument()
+	})
+
+	it("displays OAuth path from configuration", () => {
+		const apiConfiguration: ProviderSettings = {
+			geminiCliOAuthPath: "/custom/path/oauth.json",
+		}
+
+		render(<GeminiCli {...defaultProps} apiConfiguration={apiConfiguration} />)
+
+		const oauthInput = screen.getByDisplayValue("/custom/path/oauth.json")
+		expect(oauthInput).toBeInTheDocument()
+	})
+
+	it("calls setApiConfigurationField when OAuth path is changed", () => {
+		render(<GeminiCli {...defaultProps} />)
+
+		const oauthInput = screen.getByPlaceholderText("~/.gemini/oauth_creds.json")
+
+		// Simulate input event with VSCodeTextField
+		fireEvent.input(oauthInput, { target: { value: "/new/path.json" } })
+
+		// Check that setApiConfigurationField was called
+		expect(mockSetApiConfigurationField).toHaveBeenCalledWith("geminiCliOAuthPath", "/new/path.json")
+	})
+
+	it("renders setup link with correct href", () => {
+		render(<GeminiCli {...defaultProps} />)
+
+		const setupLink = screen.getByText("settings:providers.geminiCli.setupLink")
+		expect(setupLink).toHaveAttribute(
+			"href",
+			"https://github.com/google-gemini/gemini-cli?tab=readme-ov-file#quickstart",
+		)
+	})
+
+	it("shows OAuth path description", () => {
+		render(<GeminiCli {...defaultProps} />)
+
+		expect(screen.getByText("settings:providers.geminiCli.oauthPathDescription")).toBeInTheDocument()
+	})
+
+	it("renders all requirements in a list", () => {
+		render(<GeminiCli {...defaultProps} />)
+
+		const listItems = screen.getAllByRole("listitem")
+		expect(listItems).toHaveLength(5)
+		expect(listItems[0]).toHaveTextContent("settings:providers.geminiCli.requirement1")
+		expect(listItems[1]).toHaveTextContent("settings:providers.geminiCli.requirement2")
+		expect(listItems[2]).toHaveTextContent("settings:providers.geminiCli.requirement3")
+		expect(listItems[3]).toHaveTextContent("settings:providers.geminiCli.requirement4")
+		expect(listItems[4]).toHaveTextContent("settings:providers.geminiCli.requirement5")
+	})
+
+	it("applies correct styling classes", () => {
+		render(<GeminiCli {...defaultProps} />)
+
+		// Check for styled warning box
+		const warningBox = screen.getByText("settings:providers.geminiCli.requirementsTitle").closest("div.mt-3")
+		expect(warningBox).toHaveClass("bg-vscode-editorWidget-background")
+		expect(warningBox).toHaveClass("border-vscode-editorWidget-border")
+		expect(warningBox).toHaveClass("rounded")
+		expect(warningBox).toHaveClass("p-3")
+
+		// Check for warning icon
+		const warningIcon = screen.getByText("settings:providers.geminiCli.requirementsTitle").previousElementSibling
+		expect(warningIcon).toHaveClass("codicon-warning")
+		expect(warningIcon).toHaveClass("text-vscode-notificationsWarningIcon-foreground")
+
+		// Check for check icon
+		const checkIcon = screen.getByText("settings:providers.geminiCli.freeAccess").previousElementSibling
+		expect(checkIcon).toHaveClass("codicon-check")
+		expect(checkIcon).toHaveClass("text-vscode-notificationsInfoIcon-foreground")
+	})
+
+	it("renders instructions with code element", () => {
+		render(<GeminiCli {...defaultProps} />)
+
+		const codeElement = screen.getByText("gemini")
+		expect(codeElement.tagName).toBe("CODE")
+		expect(codeElement).toHaveClass("text-vscode-textPreformat-foreground")
+	})
+})

file webview-ui/src/components/settings/providers/__tests__/GeminiCli.tsx

+import { render, screen, fireEvent } from "@testing-library/react"
+import { describe, it, expect, vi } from "vitest"
+
+import type { ProviderSettings } from "@roo-code/types"
+
+import { GeminiCli } from "../GeminiCli"
+
+// Mock the translation hook
+vi.mock("@src/i18n/TranslationContext", () => ({
+	useAppTranslation: () => ({
+		t: (key: string) => key,
+	}),
+}))
+
+// Mock VSCodeLink to render as a regular anchor tag
+vi.mock("@vscode/webview-ui-toolkit/react", async () => {
+	const actual = await vi.importActual("@vscode/webview-ui-toolkit/react")
+	return {
+		...actual,
+		VSCodeLink: ({ children, href, ...props }: any) => (
+			<a href={href} {...props}>
+				{children}
+			</a>
+		),
+	}
+})
+
+describe("GeminiCli", () => {
+	const mockSetApiConfigurationField = vi.fn()
+	const defaultProps = {
+		apiConfiguration: {} as ProviderSettings,
+		setApiConfigurationField: mockSetApiConfigurationField,
+	}
+
+	beforeEach(() => {
+		vi.clearAllMocks()
+	})
+
+	it("renders all required elements", () => {
+		render(<GeminiCli {...defaultProps} />)
+
+		// Check for OAuth path input
+		expect(screen.getByText("settings:providers.geminiCli.oauthPath")).toBeInTheDocument()
+		expect(screen.getByPlaceholderText("~/.gemini/oauth_creds.json")).toBeInTheDocument()
+
+		// Check for description text
+		expect(screen.getByText("settings:providers.geminiCli.description")).toBeInTheDocument()
+
+		// Check for instructions - they're in the same div but broken up by the code element
+		// Find all elements that contain the instruction parts
+		const instructionsDivs = screen.getAllByText((_content, element) => {
+			// Check if this element contains all the expected text parts
+			const fullText = element?.textContent || ""
+			return (
+				fullText.includes("settings:providers.geminiCli.instructions") &&
+				fullText.includes("gemini") &&
+				fullText.includes("settings:providers.geminiCli.instructionsContinued")
+			)
+		})
+		// Find the div with the correct classes
+		const instructionsDiv = instructionsDivs.find(
+			(div) =>
+				div.classList.contains("text-sm") &&
+				div.classList.contains("text-vscode-descriptionForeground") &&
+				div.classList.contains("mt-2"),
+		)
+		expect(instructionsDiv).toBeDefined()
+		expect(instructionsDiv).toBeInTheDocument()
+
+		// Also verify the code element exists
+		const codeElement = screen.getByText("gemini")
+		expect(codeElement).toBeInTheDocument()
+		expect(codeElement.tagName).toBe("CODE")
+
+		// Check for setup link
+		expect(screen.getByText("settings:providers.geminiCli.setupLink")).toBeInTheDocument()
+
+		// Check for requirements
+		expect(screen.getByText("settings:providers.geminiCli.requirementsTitle")).toBeInTheDocument()
+		expect(screen.getByText("settings:providers.geminiCli.requirement1")).toBeInTheDocument()
+		expect(screen.getByText("settings:providers.geminiCli.requirement2")).toBeInTheDocument()
+		expect(screen.getByText("settings:providers.geminiCli.requirement3")).toBeInTheDocument()
+		expect(screen.getByText("settings:providers.geminiCli.requirement4")).toBeInTheDocument()
+		expect(screen.getByText("settings:providers.geminiCli.requirement5")).toBeInTheDocument()
+
+		// Check for free access note
+		expect(screen.getByText("settings:providers.geminiCli.freeAccess")).toBeInTheDocument()
+	})
+
+	it("displays OAuth path from configuration", () => {
+		const apiConfiguration: ProviderSettings = {
+			geminiCliOAuthPath: "/custom/path/oauth.json",
+		}
+
+		render(<GeminiCli {...defaultProps} apiConfiguration={apiConfiguration} />)
+
+		const oauthInput = screen.getByDisplayValue("/custom/path/oauth.json")
+		expect(oauthInput).toBeInTheDocument()
+	})
+
+	it("calls setApiConfigurationField when OAuth path is changed", () => {
+		render(<GeminiCli {...defaultProps} />)
+
+		const oauthInput = screen.getByPlaceholderText("~/.gemini/oauth_creds.json")
+
+		// Simulate input event with VSCodeTextField
+		fireEvent.input(oauthInput, { target: { value: "/new/path.json" } })
+
+		// Check that setApiConfigurationField was called
+		expect(mockSetApiConfigurationField).toHaveBeenCalledWith("geminiCliOAuthPath", "/new/path.json")
+	})
+
+	it("renders setup link with correct href", () => {
+		render(<GeminiCli {...defaultProps} />)
+
+		const setupLink = screen.getByText("settings:providers.geminiCli.setupLink")
+		expect(setupLink).toHaveAttribute(
+			"href",
+			"https://github.com/google-gemini/gemini-cli?tab=readme-ov-file#quickstart",
+		)
+	})
+
+	it("shows OAuth path description", () => {
+		render(<GeminiCli {...defaultProps} />)
+
+		expect(screen.getByText("settings:providers.geminiCli.oauthPathDescription")).toBeInTheDocument()
+	})
+
+	it("renders all requirements in a list", () => {
+		render(<GeminiCli {...defaultProps} />)
+
+		const listItems = screen.getAllByRole("listitem")
+		expect(listItems).toHaveLength(5)
+		expect(listItems[0]).toHaveTextContent("settings:providers.geminiCli.requirement1")
+		expect(listItems[1]).toHaveTextContent("settings:providers.geminiCli.requirement2")
+		expect(listItems[2]).toHaveTextContent("settings:providers.geminiCli.requirement3")
+		expect(listItems[3]).toHaveTextContent("settings:providers.geminiCli.requirement4")
+		expect(listItems[4]).toHaveTextContent("settings:providers.geminiCli.requirement5")
+	})
+
+	it("applies correct styling classes", () => {
+		render(<GeminiCli {...defaultProps} />)
+
+		// Check for styled warning box
+		const warningBox = screen.getByText("settings:providers.geminiCli.requirementsTitle").closest("div.mt-3")
+		expect(warningBox).toHaveClass("bg-vscode-editorWidget-background")
+		expect(warningBox).toHaveClass("border-vscode-editorWidget-border")
+		expect(warningBox).toHaveClass("rounded")
+		expect(warningBox).toHaveClass("p-3")
+
+		// Check for warning icon
+		const warningIcon = screen.getByText("settings:providers.geminiCli.requirementsTitle").previousElementSibling
+		expect(warningIcon).toHaveClass("codicon-warning")
+		expect(warningIcon).toHaveClass("text-vscode-notificationsWarningIcon-foreground")
+
+		// Check for check icon
+		const checkIcon = screen.getByText("settings:providers.geminiCli.freeAccess").previousElementSibling
+		expect(checkIcon).toHaveClass("codicon-check")
+		expect(checkIcon).toHaveClass("text-vscode-notificationsInfoIcon-foreground")
+	})
+
+	it("renders instructions with code element", () => {
+		render(<GeminiCli {...defaultProps} />)
+
+		const codeElement = screen.getByText("gemini")
+		expect(codeElement.tagName).toBe("CODE")
+		expect(codeElement).toHaveClass("text-vscode-textPreformat-foreground")
+	})
+})

file webview-ui/src/components/settings/providers/index.ts
label export { VSCodeLM } from "./VSCodeLM"

 export { XAI } from "./XAI"
 // kilocode_change start
 export { OvhCloudAiEndpoints } from "./OvhCloud"
+export { GeminiCli } from "./GeminiCli"
 export { VirtualQuotaFallbackProvider } from "./VirtualQuotaFallbackProvider"
 export { Inception } from "./Inception"
 export { Synthetic } from "./Synthetic"

file webview-ui/src/components/ui/hooks/useSelectedModel.ts
label import {

 	geminiModels,
 	geminiDefaultModelId,
 	// kilocode_change start
+	geminiCliDefaultModelId,
+	geminiCliModels,
 	syntheticDefaultModelId,
 	ovhCloudAiEndpointsDefaultModelId,
 	inceptionDefaultModelId,

label function getSelectedModel({

 				info: routerModels["kilocode"][invalidOrDefaultModel],
 			}
 		}
+		case "gemini-cli": {
+			const id = apiConfiguration.apiModelId ?? geminiCliDefaultModelId
+			const info = geminiCliModels[id as keyof typeof geminiCliModels]
+			return { id, info }
+		}
 		case "virtual-quota-fallback": {
 			if (virtualQuotaActiveModel) {
 				return virtualQuotaActiveModel
 		// case "human-relay":
 		// case "fake-ai":
 		default: {
+			provider satisfies "anthropic" | "gemini-cli" | "qwen-code" | "fake-ai" | "human-relay" | "kilocode"
-			provider satisfies "anthropic" | "qwen-code" | "fake-ai" | "human-relay" | "kilocode"
 			const id = apiConfiguration.apiModelId ?? defaultModelId
 			const baseInfo = anthropicModels[id as keyof typeof anthropicModels]
 

file webview-ui/src/i18n/locales/ar/settings.json

 			"maxTokensLabel": "أقصى توكنات المخرجات",
 			"maxTokensDescription": "الحد الأقصى لعدد توكنات المخرجات لردود Claude Code. الافتراضي هو 8000."
 		},
+		"geminiCli": {
+			"description": "يستخدم OAuth من أداة Gemini CLI ولا يحتاج مفاتيح.",
+			"oauthPath": "مسار بيانات OAuth (اختياري)",
+			"oauthPathDescription": "إذا تركته فاضي يستخدم المسار الافتراضي (~/.gemini/oauth_creds.json).",
+			"instructions": "إذا ما سجلت دخول، شغّل",
+			"instructionsContinued": "في الطرفية أولاً.",
+			"setupLink": "دليل إعداد Gemini CLI",
+			"requirementsTitle": "متطلبات مهمة",
+			"requirement1": "ثبت أداة Gemini CLI",
+			"requirement2": "سجل دخول بـ Google",
+			"requirement3": "يعمل مع حسابات Google الشخصية فقط",
+			"requirement4": "المصادقة تتم عبر OAuth",
+			"requirement5": "الأداة لازم تكون مثبتة ومُسجلة دخول",
+			"freeAccess": "طبقة مجانية عبر OAuth"
+		},
 		"io_intelligence": {
 			"name": "IO Intelligence",
 			"description": "ذكاء ميسور للمهام اليومية"

file webview-ui/src/i18n/locales/ca/settings.json

 			"maxTokensLabel": "Tokens màxims de sortida",
 			"maxTokensDescription": "Nombre màxim de tokens de sortida per a les respostes de Claude Code. El valor per defecte és 8000."
 		},
+		"geminiCli": {
+			"description": "Aquest proveïdor utilitza l'autenticació OAuth de l'eina Gemini CLI i no requereix claus d'API.",
+			"oauthPath": "Ruta de Credencials OAuth (opcional)",
+			"oauthPathDescription": "Ruta al fitxer de credencials OAuth. Deixa buit per utilitzar la ubicació per defecte (~/.gemini/oauth_creds.json).",
+			"instructions": "Si encara no t'has autenticat, executa",
+			"instructionsContinued": "al teu terminal primer.",
+			"setupLink": "Instruccions de Configuració de Gemini CLI",
+			"requirementsTitle": "Requisits Importants",
+			"requirement1": "Primer, necessites instal·lar l'eina Gemini CLI",
+			"requirement2": "Després, executa gemini al teu terminal i assegura't d'iniciar sessió amb Google",
+			"requirement3": "Només funciona amb comptes personals de Google (no comptes de Google Workspace)",
+			"requirement4": "No utilitza claus d'API - l'autenticació es gestiona via OAuth",
+			"requirement5": "Requereix que l'eina Gemini CLI estigui instal·lada i autenticada primer",
+			"freeAccess": "Accés gratuït via autenticació OAuth"
+		},
 		"qwenCode": {
 			"oauthPath": "Ruta de Credencials OAuth (opcional)",
 			"oauthPathDescription": "Ruta al fitxer de credencials OAuth. Deixa buit per utilitzar la ubicació per defecte (~/.qwen/oauth_creds.json).",

file webview-ui/src/i18n/locales/cs/settings.json

 			"maxTokensLabel": "Maximální počet výstupních tokenů",
 			"maxTokensDescription": "Maximální počet výstupních tokenů pro odpovědi Claude Code. Výchozí je 8000."
 		},
+		"geminiCli": {
+			"description": "Tento poskytovatel používá OAuth autentizaci z nástroje Gemini CLI a nevyžaduje klíče API.",
+			"oauthPath": "Cesta k OAuth přihlašovacím údajům (volitelné)",
+			"oauthPathDescription": "Cesta k souboru přihlašovacích údajů OAuth. Ponechte prázdné pro použití výchozího umístění (~/.gemini/oauth_creds.json).",
+			"instructions": "Pokud jste se ještě neověřili, spusťte prosím",
+			"instructionsContinued": "ve vašem terminálu nejdříve.",
+			"setupLink": "Pokyny k nastavení Gemini CLI",
+			"requirementsTitle": "Důležité požadavky",
+			"requirement1": "Nejprve musíte nainstalovat nástroj Gemini CLI",
+			"requirement2": "Poté spusťte gemini ve vašem terminálu a ujistěte se, že se přihlásíte pomocí Google",
+			"requirement3": "Funguje pouze s osobními účty Google (ne s účty Google Workspace)",
+			"requirement4": "Nepoužívá klíče API - ověřování je řešeno přes OAuth",
+			"requirement5": "Vyžaduje, aby byl nástroj Gemini CLI nejdříve nainstalován a ověřen",
+			"freeAccess": "Přístup k bezplatné úrovni prostřednictvím OAuth autentizace"
+		},
 		"io_intelligence": {
 			"name": "IO Intelligence",
 			"description": "Cenově dostupná inteligence pro každodenní úkoly"

file webview-ui/src/i18n/locales/de/settings.json

 			"maxTokensLabel": "Maximale Ausgabe-Tokens",
 			"maxTokensDescription": "Maximale Anzahl an Ausgabe-Tokens für Claude Code-Antworten. Standard ist 8000."
 		},
+		"geminiCli": {
+			"description": "Dieser Anbieter verwendet OAuth-Authentifizierung vom Gemini CLI-Tool und benötigt keine API-Schlüssel.",
+			"oauthPath": "OAuth-Anmeldedaten-Pfad (optional)",
+			"oauthPathDescription": "Pfad zur OAuth-Anmeldedaten-Datei. Leer lassen, um den Standardort zu verwenden (~/.gemini/oauth_creds.json).",
+			"instructions": "Falls du dich noch nicht authentifiziert hast, führe bitte",
+			"instructionsContinued": "in deinem Terminal zuerst aus.",
+			"setupLink": "Gemini CLI Setup-Anweisungen",
+			"requirementsTitle": "Wichtige Anforderungen",
+			"requirement1": "Zuerst musst du das Gemini CLI-Tool installieren",
+			"requirement2": "Dann führe gemini in deinem Terminal aus und stelle sicher, dass du dich mit Google anmeldest",
+			"requirement3": "Funktioniert nur mit persönlichen Google-Konten (nicht mit Google Workspace-Konten)",
+			"requirement4": "Verwendet keine API-Schlüssel - Authentifizierung wird über OAuth abgewickelt",
+			"requirement5": "Erfordert, dass das Gemini CLI-Tool zuerst installiert und authentifiziert wird",
+			"freeAccess": "Kostenloser Zugang über OAuth-Authentifizierung"
+		},
 		"qwenCode": {
 			"oauthPath": "OAuth-Anmeldedaten-Pfad (optional)",
 			"oauthPathDescription": "Pfad zur OAuth-Anmeldedaten-Datei. Leer lassen, um den Standardort zu verwenden (~/.qwen/oauth_creds.json).",

file webview-ui/src/i18n/locales/en/settings.json

 			"maxTokensLabel": "Max Output Tokens",
 			"maxTokensDescription": "Maximum number of output tokens for Claude Code responses. Default is 8000."
 		},
+		"geminiCli": {
+			"description": "This provider uses OAuth authentication from the Gemini CLI tool and does not require API keys.",
+			"oauthPath": "OAuth Credentials Path (optional)",
+			"oauthPathDescription": "Path to the OAuth credentials file. Leave empty to use the default location (~/.gemini/oauth_creds.json).",
+			"instructions": "If you haven't authenticated yet, please run",
+			"instructionsContinued": "in your terminal first.",
+			"setupLink": "Gemini CLI Setup Instructions",
+			"requirementsTitle": "Important Requirements",
+			"requirement1": "First, you need to install the Gemini CLI tool",
+			"requirement2": "Then, run gemini in your terminal and make sure you Log in with Google",
+			"requirement3": "Only works with personal Google accounts (not Google Workspace accounts)",
+			"requirement4": "Does not use API keys - authentication is handled via OAuth",
+			"requirement5": "Requires the Gemini CLI tool to be installed and authenticated first",
+			"freeAccess": "Free tier access via OAuth authentication"
+		},
 		"qwenCode": {
 			"oauthPath": "OAuth Credentials Path (optional)",
 			"oauthPathDescription": "Path to the OAuth credentials file. Leave empty to use the default location (~/.qwen/oauth_creds.json).",

file webview-ui/src/i18n/locales/es/settings.json

 			"maxTokensLabel": "Tokens máximos de salida",
 			"maxTokensDescription": "Número máximo de tokens de salida para las respuestas de Claude Code. El valor predeterminado es 8000."
 		},
+		"geminiCli": {
+			"description": "Este proveedor usa autenticación OAuth de la herramienta Gemini CLI y no requiere claves API.",
+			"oauthPath": "Ruta de Credenciales OAuth (opcional)",
+			"oauthPathDescription": "Ruta al archivo de credenciales OAuth. Deja vacío para usar la ubicación predeterminada (~/.gemini/oauth_creds.json).",
+			"instructions": "Si aún no te has autenticado, por favor ejecuta",
+			"instructionsContinued": "en tu terminal primero.",
+			"setupLink": "Instrucciones de Configuración de Gemini CLI",
+			"requirementsTitle": "Requisitos Importantes",
+			"requirement1": "Primero, necesitas instalar la herramienta Gemini CLI",
+			"requirement2": "Luego, ejecuta gemini en tu terminal y asegúrate de iniciar sesión con Google",
+			"requirement3": "Solo funciona con cuentas personales de Google (no cuentas de Google Workspace)",
+			"requirement4": "No usa claves API - la autenticación se maneja vía OAuth",
+			"requirement5": "Requiere que la herramienta Gemini CLI esté instalada y autenticada primero",
+			"freeAccess": "Acceso gratuito vía autenticación OAuth"
+		},
 		"qwenCode": {
 			"oauthPath": "Ruta de Credenciales OAuth (opcional)",
 			"oauthPathDescription": "Ruta al archivo de credenciales OAuth. Deja vacío para usar la ubicación predeterminada (~/.qwen/oauth_creds.json).",

file webview-ui/src/i18n/locales/fr/settings.json

 			"maxTokensLabel": "Jetons de sortie max",
 			"maxTokensDescription": "Nombre maximum de jetons de sortie pour les réponses de Claude Code. La valeur par défaut est 8000."
 		},
+		"geminiCli": {
+			"description": "Ce fournisseur utilise l'authentification OAuth de l'outil Gemini CLI et ne nécessite pas de clés API.",
+			"oauthPath": "Chemin des Identifiants OAuth (optionnel)",
+			"oauthPathDescription": "Chemin vers le fichier d'identifiants OAuth. Laissez vide pour utiliser l'emplacement par défaut (~/.gemini/oauth_creds.json).",
+			"instructions": "Si vous ne vous êtes pas encore authentifié, veuillez exécuter",
+			"instructionsContinued": "dans votre terminal d'abord.",
+			"setupLink": "Instructions de Configuration Gemini CLI",
+			"requirementsTitle": "Exigences Importantes",
+			"requirement1": "D'abord, vous devez installer l'outil Gemini CLI",
+			"requirement2": "Ensuite, exécutez gemini dans votre terminal et assurez-vous de vous connecter avec Google",
+			"requirement3": "Fonctionne uniquement avec les comptes Google personnels (pas les comptes Google Workspace)",
+			"requirement4": "N'utilise pas de clés API - l'authentification est gérée via OAuth",
+			"requirement5": "Nécessite que l'outil Gemini CLI soit installé et authentifié d'abord",
+			"freeAccess": "Accès gratuit via l'authentification OAuth"
+		},
 		"qwenCode": {
 			"oauthPath": "Chemin des identifiants OAuth (optionnel)",
 			"oauthPathDescription": "Chemin vers le fichier d'identifiants OAuth. Laissez vide pour utiliser l'emplacement par défaut (~/.qwen/oauth_creds.json).",

file webview-ui/src/i18n/locales/hi/settings.json

 			"maxTokensLabel": "अधिकतम आउटपुट टोकन",
 			"maxTokensDescription": "Claude Code प्रतिक्रियाओं के लिए आउटपुट टोकन की अधिकतम संख्या। डिफ़ॉल्ट 8000 है।"
 		},
+		"geminiCli": {
+			"description": "यह प्रदाता Gemini CLI टूल से OAuth प्रमाणीकरण का उपयोग करता है और API कुंजियों की आवश्यकता नहीं है।",
+			"oauthPath": "OAuth क्रेडेंशियल पथ (वैकल्पिक)",
+			"oauthPathDescription": "OAuth क्रेडेंशियल फ़ाइल का पथ। डिफ़ॉल्ट स्थान (~/.gemini/oauth_creds.json) का उपयोग करने के लिए खाली छोड़ें।",
+			"instructions": "यदि आपने अभी तक प्रमाणीकरण नहीं किया है, तो कृपया पहले",
+			"instructionsContinued": "को अपने टर्मिनल में चलाएं।",
+			"setupLink": "Gemini CLI सेटअप निर्देश",
+			"requirementsTitle": "महत्वपूर्ण आवश्यकताएं",
+			"requirement1": "पहले, आपको Gemini CLI टूल इंस्टॉल करना होगा",
+			"requirement2": "फिर, अपने टर्मिनल में gemini चलाएं और सुनिश्चित करें कि आप Google से लॉग इन करें",
+			"requirement3": "केवल व्यक्तिगत Google खातों के साथ काम करता है (Google Workspace खाते नहीं)",
+			"requirement4": "API कुंजियों का उपयोग नहीं करता - प्रमाणीकरण OAuth के माध्यम से संभाला जाता है",
+			"requirement5": "Gemini CLI टूल को पहले इंस्टॉल और प्रमाणित करने की आवश्यकता है",
+			"freeAccess": "OAuth प्रमाणीकरण के माध्यम से मुफ्त पहुंच"
+		},
 		"qwenCode": {
 			"oauthPath": "OAuth क्रेडेंशियल पथ (वैकल्पिक)",
 			"oauthPathDescription": "OAuth क्रेडेंशियल फ़ाइल का पथ। डिफ़ॉल्ट स्थान (~/.qwen/oauth_creds.json) का उपयोग करने के लिए खाली छोड़ें।",

file webview-ui/src/i18n/locales/id/settings.json

 			"maxTokensLabel": "Token Output Maks",
 			"maxTokensDescription": "Jumlah maksimum token output untuk respons Claude Code. Default adalah 8000."
 		},
+		"geminiCli": {
+			"description": "Penyedia ini menggunakan autentikasi OAuth dari alat Gemini CLI dan tidak memerlukan kunci API.",
+			"oauthPath": "Jalur Kredensial OAuth (opsional)",
+			"oauthPathDescription": "Jalur ke file kredensial OAuth. Biarkan kosong untuk menggunakan lokasi default (~/.gemini/oauth_creds.json).",
+			"instructions": "Jika Anda belum melakukan autentikasi, jalankan",
+			"instructionsContinued": "di terminal Anda terlebih dahulu.",
+			"setupLink": "Petunjuk Pengaturan Gemini CLI",
+			"requirementsTitle": "Persyaratan Penting",
+			"requirement1": "Pertama, Anda perlu menginstal alat Gemini CLI",
+			"requirement2": "Kemudian, jalankan gemini di terminal Anda dan pastikan Anda masuk dengan Google",
+			"requirement3": "Hanya berfungsi dengan akun Google pribadi (bukan akun Google Workspace)",
+			"requirement4": "Tidak menggunakan kunci API - autentikasi ditangani melalui OAuth",
+			"requirement5": "Memerlukan alat Gemini CLI diinstal dan diautentikasi terlebih dahulu",
+			"freeAccess": "Akses gratis melalui autentikasi OAuth"
+		},
 		"qwenCode": {
 			"oauthPath": "Jalur Kredensial OAuth (opsional)",
 			"oauthPathDescription": "Jalur ke file kredensial OAuth. Biarkan kosong untuk menggunakan lokasi default (~/.qwen/oauth_creds.json).",

file webview-ui/src/i18n/locales/it/settings.json

 			"maxTokensLabel": "Token di output massimi",
 			"maxTokensDescription": "Numero massimo di token di output per le risposte di Claude Code. Il valore predefinito è 8000."
 		},
+		"geminiCli": {
+			"description": "Questo provider utilizza l'autenticazione OAuth dallo strumento Gemini CLI e non richiede chiavi API.",
+			"oauthPath": "Percorso Credenziali OAuth (opzionale)",
+			"oauthPathDescription": "Percorso al file delle credenziali OAuth. Lascia vuoto per utilizzare la posizione predefinita (~/.gemini/oauth_creds.json).",
+			"instructions": "Se non ti sei ancora autenticato, esegui",
+			"instructionsContinued": "nel tuo terminale prima.",
+			"setupLink": "Istruzioni di Configurazione Gemini CLI",
+			"requirementsTitle": "Requisiti Importanti",
+			"requirement1": "Prima, devi installare lo strumento Gemini CLI",
+			"requirement2": "Poi, esegui gemini nel tuo terminale e assicurati di accedere con Google",
+			"requirement3": "Funziona solo con account Google personali (non account Google Workspace)",
+			"requirement4": "Non utilizza chiavi API - l'autenticazione è gestita tramite OAuth",
+			"requirement5": "Richiede che lo strumento Gemini CLI sia installato e autenticato prima",
+			"freeAccess": "Accesso gratuito tramite autenticazione OAuth"
+		},
 		"qwenCode": {
 			"oauthPath": "Percorso credenziali OAuth (opzionale)",
 			"oauthPathDescription": "Percorso al file delle credenziali OAuth. Lascia vuoto per utilizzare la posizione predefinita (~/.qwen/oauth_creds.json).",

file webview-ui/src/i18n/locales/ja/settings.json

 			"maxTokensLabel": "最大出力トークン",
 			"maxTokensDescription": "Claude Codeレスポンスの最大出力トークン数。デフォルトは8000です。"
 		},
+		"geminiCli": {
+			"description": "このプロバイダーはGemini CLIツールからのOAuth認証を使用し、APIキーは必要ありません。",
+			"oauthPath": "OAuth認証情報パス（オプション）",
+			"oauthPathDescription": "OAuth認証情報ファイルへのパス。デフォルトの場所（~/.gemini/oauth_creds.json）を使用する場合は空のままにしてください。",
+			"instructions": "まだ認証していない場合は、まず",
+			"instructionsContinued": "をターミナルで実行してください。",
+			"setupLink": "Gemini CLI セットアップ手順",
+			"requirementsTitle": "重要な要件",
+			"requirement1": "まず、Gemini CLIツールをインストールする必要があります",
+			"requirement2": "次に、ターミナルでgeminiを実行し、Googleでログインすることを確認してください",
+			"requirement3": "個人のGoogleアカウントでのみ動作します（Google Workspaceアカウントは不可）",
+			"requirement4": "APIキーは使用しません - 認証はOAuthで処理されます",
+			"requirement5": "Gemini CLIツールが最初にインストールされ、認証されている必要があります",
+			"freeAccess": "OAuth認証による無料アクセス"
+		},
 		"qwenCode": {
 			"oauthPath": "OAuth認証情報パス（オプション）",
 			"oauthPathDescription": "OAuth認証情報ファイルへのパス。デフォルトの場所（~/.qwen/oauth_creds.json）を使用する場合は空のままにしてください。",

file webview-ui/src/i18n/locales/ko/settings.json

 			"maxTokensLabel": "최대 출력 토큰",
 			"maxTokensDescription": "Claude Code 응답의 최대 출력 토큰 수. 기본값은 8000입니다."
 		},
+		"geminiCli": {
+			"description": "이 공급자는 Gemini CLI 도구의 OAuth 인증을 사용하며 API 키가 필요하지 않습니다.",
+			"oauthPath": "OAuth 자격 증명 경로 (선택사항)",
+			"oauthPathDescription": "OAuth 자격 증명 파일의 경로입니다. 기본 위치(~/.gemini/oauth_creds.json)를 사용하려면 비워두세요.",
+			"instructions": "아직 인증하지 않았다면",
+			"instructionsContinued": "를 터미널에서 먼저 실행하세요.",
+			"setupLink": "Gemini CLI 설정 지침",
+			"requirementsTitle": "중요한 요구사항",
+			"requirement1": "먼저 Gemini CLI 도구를 설치해야 합니다",
+			"requirement2": "그 다음 터미널에서 gemini를 실행하고 Google로 로그인했는지 확인하세요",
+			"requirement3": "개인 Google 계정에서만 작동합니다 (Google Workspace 계정 불가)",
+			"requirement4": "API 키를 사용하지 않습니다 - 인증은 OAuth를 통해 처리됩니다",
+			"requirement5": "Gemini CLI 도구가 먼저 설치되고 인증되어야 합니다",
+			"freeAccess": "OAuth 인증을 통한 무료 액세스"
+		},
 		"qwenCode": {
 			"oauthPath": "OAuth 자격 증명 경로 (선택사항)",
 			"oauthPathDescription": "OAuth 자격 증명 파일의 경로입니다. 기본 위치(~/.qwen/oauth_creds.json)를 사용하려면 비워두세요.",

file webview-ui/src/i18n/locales/nl/settings.json

 			"maxTokensLabel": "Max Output Tokens",
 			"maxTokensDescription": "Maximaal aantal output-tokens voor Claude Code-reacties. Standaard is 8000."
 		},
+		"geminiCli": {
+			"description": "Deze provider gebruikt OAuth-authenticatie van de Gemini CLI-tool en vereist geen API-sleutels.",
+			"oauthPath": "OAuth-referentiepad (optioneel)",
+			"oauthPathDescription": "Pad naar het OAuth-referentiebestand. Laat leeg om de standaardlocatie te gebruiken (~/.gemini/oauth_creds.json).",
+			"instructions": "Als je nog niet bent geauthenticeerd, voer dan eerst",
+			"instructionsContinued": "uit in je terminal.",
+			"setupLink": "Gemini CLI Setup-instructies",
+			"requirementsTitle": "Belangrijke vereisten",
+			"requirement1": "Eerst moet je de Gemini CLI-tool installeren",
+			"requirement2": "Voer vervolgens gemini uit in je terminal en zorg ervoor dat je inlogt met Google",
+			"requirement3": "Werkt alleen met persoonlijke Google-accounts (geen Google Workspace-accounts)",
+			"requirement4": "Gebruikt geen API-sleutels - authenticatie wordt afgehandeld via OAuth",
+			"requirement5": "Vereist dat de Gemini CLI-tool eerst wordt geïnstalleerd en geauthenticeerd",
+			"freeAccess": "Gratis toegang via OAuth-authenticatie"
+		},
 		"qwenCode": {
 			"oauthPath": "OAuth-referentiepad (optioneel)",
 			"oauthPathDescription": "Pad naar het OAuth-referentiebestand. Laat leeg om de standaardlocatie te gebruiken (~/.qwen/oauth_creds.json).",

file webview-ui/src/i18n/locales/pl/settings.json

 			"maxTokensLabel": "Maksymalna liczba tokenów wyjściowych",
 			"maxTokensDescription": "Maksymalna liczba tokenów wyjściowych dla odpowiedzi Claude Code. Domyślnie 8000."
 		},
+		"geminiCli": {
+			"description": "Ten dostawca używa uwierzytelniania OAuth z narzędzia Gemini CLI i nie wymaga kluczy API.",
+			"oauthPath": "Ścieżka danych uwierzytelniających OAuth (opcjonalne)",
+			"oauthPathDescription": "Ścieżka do pliku danych uwierzytelniających OAuth. Pozostaw puste, aby użyć domyślnej lokalizacji (~/.gemini/oauth_creds.json).",
+			"instructions": "Jeśli jeszcze się nie uwierzytelniłeś, uruchom najpierw",
+			"instructionsContinued": "w swoim terminalu.",
+			"setupLink": "Instrukcje konfiguracji Gemini CLI",
+			"requirementsTitle": "Ważne wymagania",
+			"requirement1": "Najpierw musisz zainstalować narzędzie Gemini CLI",
+			"requirement2": "Następnie uruchom gemini w swoim terminalu i upewnij się, że logujesz się przez Google",
+			"requirement3": "Działa tylko z osobistymi kontami Google (nie z kontami Google Workspace)",
+			"requirement4": "Nie używa kluczy API - uwierzytelnianie jest obsługiwane przez OAuth",
+			"requirement5": "Wymaga, aby narzędzie Gemini CLI było najpierw zainstalowane i uwierzytelnione",
+			"freeAccess": "Darmowy dostęp przez uwierzytelnianie OAuth"
+		},
 		"qwenCode": {
 			"oauthPath": "Ścieżka danych uwierzytelniających OAuth (opcjonalne)",
 			"oauthPathDescription": "Ścieżka do pliku danych uwierzytelniających OAuth. Pozostaw puste, aby użyć domyślnej lokalizacji (~/.qwen/oauth_creds.json).",

file webview-ui/src/i18n/locales/pt-BR/settings.json

 			"maxTokensLabel": "Tokens de saída máximos",
 			"maxTokensDescription": "Número máximo de tokens de saída para respostas do Claude Code. O padrão é 8000."
 		},
+		"geminiCli": {
+			"description": "Este provedor usa autenticação OAuth da ferramenta Gemini CLI e não requer chaves de API.",
+			"oauthPath": "Caminho das Credenciais OAuth (opcional)",
+			"oauthPathDescription": "Caminho para o arquivo de credenciais OAuth. Deixe vazio para usar o local padrão (~/.gemini/oauth_creds.json).",
+			"instructions": "Se você ainda não se autenticou, execute",
+			"instructionsContinued": "no seu terminal primeiro.",
+			"setupLink": "Instruções de Configuração do Gemini CLI",
+			"requirementsTitle": "Requisitos Importantes",
+			"requirement1": "Primeiro, você precisa instalar a ferramenta Gemini CLI",
+			"requirement2": "Em seguida, execute gemini no seu terminal e certifique-se de fazer login com o Google",
+			"requirement3": "Funciona apenas com contas pessoais do Google (não contas do Google Workspace)",
+			"requirement4": "Não usa chaves de API - a autenticação é tratada via OAuth",
+			"requirement5": "Requer que a ferramenta Gemini CLI seja instalada e autenticada primeiro",
+			"freeAccess": "Acesso gratuito via autenticação OAuth"
+		},
 		"qwenCode": {
 			"oauthPath": "Caminho das Credenciais OAuth (opcional)",
 			"oauthPathDescription": "Caminho para o arquivo de credenciais OAuth. Deixe vazio para usar o local padrão (~/.qwen/oauth_creds.json).",

file webview-ui/src/i18n/locales/ru/settings.json

 			"maxTokensLabel": "Макс. выходных токенов",
 			"maxTokensDescription": "Максимальное количество выходных токенов для ответов Claude Code. По умолчанию 8000."
 		},
+		"geminiCli": {
+			"description": "Этот провайдер использует OAuth-аутентификацию из инструмента Gemini CLI и не требует API-ключей.",
+			"oauthPath": "Путь к учетным данным OAuth (необязательно)",
+			"oauthPathDescription": "Путь к файлу учетных данных OAuth. Оставьте пустым для использования местоположения по умолчанию (~/.gemini/oauth_creds.json).",
+			"instructions": "Если вы еще не прошли аутентификацию, выполните",
+			"instructionsContinued": "в вашем терминале сначала.",
+			"setupLink": "Инструкции по настройке Gemini CLI",
+			"requirementsTitle": "Важные требования",
+			"requirement1": "Сначала вам нужно установить инструмент Gemini CLI",
+			"requirement2": "Затем запустите gemini в вашем терминале и убедитесь, что вы вошли в Google",
+			"requirement3": "Работает только с личными аккаунтами Google (не с аккаунтами Google Workspace)",
+			"requirement4": "Не использует API-ключи - аутентификация обрабатывается через OAuth",
+			"requirement5": "Требует, чтобы инструмент Gemini CLI был сначала установлен и аутентифицирован",
+			"freeAccess": "Бесплатный доступ через OAuth-аутентификацию"
+		},
 		"qwenCode": {
 			"oauthPath": "Путь к учетным данным OAuth (необязательно)",
 			"oauthPathDescription": "Путь к файлу учетных данных OAuth. Оставьте пустым для использования местоположения по умолчанию (~/.qwen/oauth_creds.json).",

file webview-ui/src/i18n/locales/th/settings.json

 			"maxTokensLabel": "โทเค็นเอาต์พุตสูงสุด",
 			"maxTokensDescription": "จำนวนโทเค็นเอาต์พุตสูงสุดสำหรับการตอบสนองของ Claude Code ค่าเริ่มต้นคือ 8000"
 		},
+		"geminiCli": {
+			"description": "ผู้ให้บริการนี้ใช้การยืนยันตัวตน OAuth จากเครื่องมือ Gemini CLI และไม่ต้องการกุญแจ API",
+			"oauthPath": "เส้นทางข้อมูลประจำตัว OAuth (ไม่บังคับ)",
+			"oauthPathDescription": "เส้นทางไปยังไฟล์ข้อมูลประจำตัว OAuth ปล่อยว่างไว้เพื่อใช้ตำแหน่งเริ่มต้น (~/.gemini/oauth_creds.json)",
+			"instructions": "หากคุณยังไม่ได้ยืนยันตัวตน โปรดรัน",
+			"instructionsContinued": "ใน terminal ของคุณก่อน",
+			"setupLink": "คำแนะนำการตั้งค่า Gemini CLI",
+			"requirementsTitle": "ข้อกำหนดที่สำคัญ",
+			"requirement1": "ก่อนอื่น คุณต้องติดตั้งเครื่องมือ Gemini CLI",
+			"requirement2": "จากนั้น รัน gemini ใน terminal ของคุณและตรวจสอบให้แน่ใจว่าคุณเข้าสู่ระบบด้วย Google",
+			"requirement3": "ใช้งานได้เฉพาะกับบัญชี Google ส่วนตัว (ไม่ใช่บัญชี Google Workspace)",
+			"requirement4": "ไม่ใช้กุญแจ API - การยืนยันตัวตนจัดการผ่าน OAuth",
+			"requirement5": "ต้องการให้เครื่องมือ Gemini CLI ถูกติดตั้งและยืนยันตัวตนก่อน",
+			"freeAccess": "การเข้าถึงระดับฟรีผ่านการยืนยันตัวตน OAuth"
+		},
 		"io_intelligence": {
 			"name": "IO Intelligence",
 			"description": "ความฉลาดราคาประหยัดสำหรับงานประจำวัน"

file webview-ui/src/i18n/locales/tr/settings.json

 			"maxTokensLabel": "Maksimum Çıktı Token sayısı",
 			"maxTokensDescription": "Claude Code yanıtları için maksimum çıktı token sayısı. Varsayılan 8000'dir."
 		},
+		"geminiCli": {
+			"description": "Bu sağlayıcı Gemini CLI aracından OAuth kimlik doğrulaması kullanır ve API anahtarları gerektirmez.",
+			"oauthPath": "OAuth Kimlik Bilgileri Yolu (isteğe bağlı)",
+			"oauthPathDescription": "OAuth kimlik bilgileri dosyasının yolu. Varsayılan konumu kullanmak için boş bırakın (~/.gemini/oauth_creds.json).",
+			"instructions": "Henüz kimlik doğrulaması yapmadıysanız, önce",
+			"instructionsContinued": "komutunu terminalinizde çalıştırın.",
+			"setupLink": "Gemini CLI Kurulum Talimatları",
+			"requirementsTitle": "Önemli Gereksinimler",
+			"requirement1": "Önce Gemini CLI aracını yüklemeniz gerekir",
+			"requirement2": "Sonra terminalinizde gemini çalıştırın ve Google ile giriş yaptığınızdan emin olun",
+			"requirement3": "Sadece kişisel Google hesaplarıyla çalışır (Google Workspace hesapları değil)",
+			"requirement4": "API anahtarları kullanmaz - kimlik doğrulama OAuth ile yapılır",
+			"requirement5": "Gemini CLI aracının önce yüklenmesi ve kimlik doğrulaması yapılması gerekir",
+			"freeAccess": "OAuth kimlik doğrulaması ile ücretsiz erişim"
+		},
 		"qwenCode": {
 			"oauthPath": "OAuth Kimlik Bilgileri Yolu (isteğe bağlı)",
 			"oauthPathDescription": "OAuth kimlik bilgileri dosyasının yolu. Varsayılan konumu kullanmak için boş bırakın (~/.qwen/oauth_creds.json).",

file webview-ui/src/i18n/locales/uk/settings.json

 			"maxTokensLabel": "Макс. вихідних токенів",
 			"maxTokensDescription": "Максимальна кількість вихідних токенів для відповідей Claude Code. За замовчуванням 8000."
 		},
+		"geminiCli": {
+			"description": "Цей провайдер використовує OAuth-аутентифікацію інструменту Gemini CLI і не потребує API-ключів.",
+			"oauthPath": "Шлях до облікових даних OAuth (необов'язково)",
+			"oauthPathDescription": "Шлях до файлу облікових даних OAuth. Залиште порожнім для використання місця за замовчуванням (~/.gemini/oauth_creds.json).",
+			"instructions": "Якщо ти ще не пройшов аутентифікацію, будь ласка, виконай",
+			"instructionsContinued": "у своєму терміналі спочатку.",
+			"setupLink": "Інструкції налаштування Gemini CLI",
+			"requirementsTitle": "Важливі вимоги",
+			"requirement1": "Спочатку тобі потрібно встановити інструмент Gemini CLI",
+			"requirement2": "Потім запусти gemini у своєму терміналі і переконайся, що увійшов через Google",
+			"requirement3": "Працює лише з особистими обліковими записами Google (не обліковими записами Google Workspace)",
+			"requirement4": "Не використовує API-ключі - аутентифікація здійснюється через OAuth",
+			"requirement5": "Потребує, щоб інструмент Gemini CLI був спочатку встановлений і аутентифікований",
+			"freeAccess": "Безкоштовний доступ через OAuth-аутентифікацію"
+		},
 		"io_intelligence": {
 			"name": "IO Intelligence",
 			"description": "Доступний штучний інтелект для повсякденних завдань"

file webview-ui/src/i18n/locales/vi/settings.json

 			"maxTokensLabel": "Số token đầu ra tối đa",
 			"maxTokensDescription": "Số lượng token đầu ra tối đa cho các phản hồi của Claude Code. Mặc định là 8000."
 		},
+		"geminiCli": {
+			"description": "Nhà cung cấp này sử dụng xác thực OAuth từ công cụ Gemini CLI và không yêu cầu khóa API.",
+			"oauthPath": "Đường dẫn Thông tin xác thực OAuth (tùy chọn)",
+			"oauthPathDescription": "Đường dẫn đến tệp thông tin xác thực OAuth. Để trống để sử dụng vị trí mặc định (~/.gemini/oauth_creds.json).",
+			"instructions": "Nếu bạn chưa xác thực, vui lòng chạy",
+			"instructionsContinued": "trong terminal của bạn trước.",
+			"setupLink": "Hướng dẫn Thiết lập Gemini CLI",
+			"requirementsTitle": "Yêu cầu Quan trọng",
+			"requirement1": "Trước tiên, bạn cần cài đặt công cụ Gemini CLI",
+			"requirement2": "Sau đó, chạy gemini trong terminal của bạn và đảm bảo bạn đăng nhập bằng Google",
+			"requirement3": "Chỉ hoạt động với tài khoản Google cá nhân (không phải tài khoản Google Workspace)",
+			"requirement4": "Không sử dụng khóa API - xác thực được xử lý qua OAuth",
+			"requirement5": "Yêu cầu công cụ Gemini CLI được cài đặt và xác thực trước",
+			"freeAccess": "Truy cập miễn phí qua xác thực OAuth"
+		},
 		"qwenCode": {
 			"oauthPath": "Đường dẫn Thông tin xác thực OAuth (tùy chọn)",
 			"oauthPathDescription": "Đường dẫn đến tệp thông tin xác thực OAuth. Để trống để sử dụng vị trí mặc định (~/.qwen/oauth_creds.json).",

file webview-ui/src/i18n/locales/zh-CN/settings.json

 			"maxTokensLabel": "最大输出 Token",
 			"maxTokensDescription": "Claude Code 响应的最大输出 Token 数量。默认为 8000。"
 		},
+		"geminiCli": {
+			"description": "此提供商使用 Gemini CLI 工具的 OAuth 身份验证，不需要 API 密钥。",
+			"oauthPath": "OAuth 凭据路径（可选）",
+			"oauthPathDescription": "OAuth 凭据文件的路径。留空以使用默认位置（~/.gemini/oauth_creds.json）。",
+			"instructions": "如果您尚未进行身份验证，请先运行",
+			"instructionsContinued": "在您的终端中。",
+			"setupLink": "Gemini CLI 设置说明",
+			"requirementsTitle": "重要要求",
+			"requirement1": "首先，您需要安装 Gemini CLI 工具",
+			"requirement2": "然后，在终端中运行 gemini 并确保使用 Google 登录",
+			"requirement3": "仅适用于个人 Google 账户（不支持 Google Workspace 账户）",
+			"requirement4": "不使用 API 密钥 - 身份验证通过 OAuth 处理",
+			"requirement5": "需要先安装并验证 Gemini CLI 工具",
+			"freeAccess": "通过 OAuth 身份验证免费访问"
+		},
 		"qwenCode": {
 			"oauthPath": "OAuth 凭据路径（可选）",
 			"oauthPathDescription": "OAuth 凭据文件的路径。留空以使用默认位置（~/.qwen/oauth_creds.json）。",

file webview-ui/src/i18n/locales/zh-TW/settings.json

 			"maxTokensLabel": "最大輸出 Token",
 			"maxTokensDescription": "Claude Code 回應的最大輸出 Token 數量。預設為 8000。"
 		},
+		"geminiCli": {
+			"description": "此供應商使用 Gemini CLI 工具的 OAuth 身份驗證，不需要 API 金鑰。",
+			"oauthPath": "OAuth 憑證路徑（可選）",
+			"oauthPathDescription": "OAuth 憑證檔案的路徑。留空以使用預設位置（~/.gemini/oauth_creds.json）。",
+			"instructions": "如果您尚未進行身份驗證，請先執行",
+			"instructionsContinued": "在您的終端機中。",
+			"setupLink": "Gemini CLI 設定說明",
+			"requirementsTitle": "重要要求",
+			"requirement1": "首先，您需要安裝 Gemini CLI 工具",
+			"requirement2": "然後，在終端機中執行 gemini 並確保使用 Google 登入",
+			"requirement3": "僅適用於個人 Google 帳戶（不支援 Google Workspace 帳戶）",
+			"requirement4": "不使用 API 金鑰 - 身份驗證透過 OAuth 處理",
+			"requirement5": "需要先安裝並驗證 Gemini CLI 工具",
+			"freeAccess": "透過 OAuth 身份驗證免費存取"
+		},
 		"qwenCode": {
 			"oauthPath": "OAuth 憑證路徑（選用）",
 			"oauthPathDescription": "OAuth 憑證檔案的路徑。留空以使用預設位置（~/.qwen/oauth_creds.json）。",

file webview-ui/src/utils/validate.ts
label function validateModelsAndKeysProvided(apiConfiguration: ProviderSettings): stri

 				return i18next.t("settings:validation.apiKey")
 			}
 			break
+		// kilocode_change start
+		case "gemini-cli":
+			// OAuth-based provider, no API key validation needed
+			break
+		// kilocode_change end
 		case "openai-native":
 			if (!apiConfiguration.openAiNativeApiKey) {
 				return i18next.t("settings:validation.apiKey")
