file packages/types/src/global-settings.ts
label export const globalSettingsSchema = z.object({

 	lastModeExportPath: z.string().optional(),
 	lastModeImportPath: z.string().optional(),
 	appendSystemPrompt: z.string().optional(), // kilocode_change: Custom text to append to system prompt (CLI only)
+	alwaysAllowRalph: z.boolean().optional(),
+	ralphEnabled: z.boolean().optional(),
+	ralphLoopLimit: z.number().int().min(0).optional(),
+	ralphCompletionDelimiter: z.string().optional(),
+	ralphKeepCurrentTask: z.boolean().optional(),
 })
 
 export type GlobalSettings = z.infer<typeof globalSettingsSchema>

label export const EVALS_SETTINGS: RooCodeSettings = {

 	alwaysAllowModeSwitch: true,
 	alwaysAllowSubtasks: true,
 	alwaysAllowExecute: true,
+	alwaysAllowRalph: false,
+	ralphLoopLimit: 5,
+	ralphCompletionDelimiter: "<ralph>COMPLETED</ralph>",
+	ralphKeepCurrentTask: true,
 	alwaysAllowFollowupQuestions: true,
 	followupAutoApproveTimeoutMs: 0,
 	allowedCommands: ["*"],

file packages/types/src/task.ts
label export interface CreateTaskOptions {

 	initialTodos?: TodoItem[]
 	/** Initial status for the task's history item (e.g., "active" for child tasks) */
 	initialStatus?: "active" | "delegated" | "completed"
+	ralphLoopCount?: number
+	mode?: string
 }
 
 export enum TaskStatus {
 	Running = "running",
 	Interactive = "interactive",
 	Resumable = "resumable",
 	Idle = "idle",
 	None = "none",
 }
 
 export const taskMetadataSchema = z.object({
 	task: z.string().optional(),
 	images: z.array(z.string()).optional(),
+	ralphLoopCount: z.number().int().min(0).optional(),
+	mode: z.string().optional(),
 })
 
 export type TaskMetadata = z.infer<typeof taskMetadataSchema>

file packages/types/src/vscode-extension-host.ts
label export type ExtensionState = Pick<

 	| "alwaysAllowSubtasks"
 	| "alwaysAllowFollowupQuestions"

+	| "alwaysAllowRalph"
 	| "followupAutoApproveTimeoutMs"
 	| "allowedCommands"
 	| "deniedCommands"

label export type ExtensionState = Pick<

 	| "maxGitStatusFiles"
 	| "requestDelaySeconds"

+	| "ralphEnabled"
+	| "ralphLoopLimit"
+	| "ralphCompletionDelimiter"
+	| "ralphKeepCurrentTask"
 > & {
 	version: string
 	clineMessages: ClineMessage[]

label export interface WebviewMessage {

 		| "requestClaudeCodeRateLimits"
 		| "requestOpenAiCodexRateLimits"
 		| "refreshCustomTools"
+		| "ralphEnabled"
+		| "ralphLoopLimit"
+		| "ralphCompletionDelimiter"
+		| "ralphKeepCurrentTask"
 		| "requestModes"
 		| "switchMode"
 		| "debugSetting"

file src/core/assistant-message/presentAssistantMessage.ts
label export async function presentAssistantMessage(cline: Task) {

 				// If execution is not allowed, notify user and break.
 				if (!repetitionCheck.allowExecution && repetitionCheck.askUser) {
 					// Handle repetition similar to mistake_limit_reached pattern.
-					const { response, text, images } = await cline.ask(
-						repetitionCheck.askUser.messageKey as ClineAsk,
+					const result = await cline.handleMistakeLimitReached(
 						repetitionCheck.askUser.messageDetail.replace("{toolName}", block.name),
 					)
 
+					if (!result) {
+						return
+					}
+
+					const { response, text, images } = result
+
 					if (response === "messageResponse") {
 						// Add user feedback to userContent.
 						cline.userMessageContent.push(

file src/core/task/Task.ts
label const MAX_CHUTES_TERMINATED_RETRY_ATTEMPTS = 2 // Allow up to 2 retries (3 total

 export interface TaskOptions extends CreateTaskOptions {
 	context: vscode.ExtensionContext // kilocode_change
 	provider: ClineProvider
+	ralphLoopCount?: number
 	apiConfiguration: ProviderSettings
 	enableDiff?: boolean
 	enableCheckpoints?: boolean

label export class Task extends EventEmitter<TaskEvents> implements TaskLike {

 		initialTodos,
 		workspacePath,
 		initialStatus,
+		ralphLoopCount,
 	}: TaskOptions) {
 		super()
 		this.context = context // kilocode_change

label export class Task extends EventEmitter<TaskEvents> implements TaskLike {

 		this.metadata = {
 			task: historyItem ? historyItem.task : task,
 			images: historyItem ? [] : images,
+			ralphLoopCount: ralphLoopCount ?? 0,
+			mode: historyItem ? historyItem.mode : undefined,
 		}
 
 		// Normal use-case is usually retry similar history task with new workspace.

label export class Task extends EventEmitter<TaskEvents> implements TaskLike {

 		try {
 			const state = await provider.getState()
 			this._taskMode = state?.mode || defaultModeSlug
+			this.metadata.mode = this._taskMode
 		} catch (error) {
 			// If there's an error getting state, use the default mode
 			this._taskMode = defaultModeSlug
+			this.metadata.mode = this._taskMode
 			// Use the provider's log method for better error visibility
 			const errorMessage = `Failed to initialize task mode: ${error instanceof Error ? error.message : String(error)}`
 			provider.log(errorMessage)

label export class Task extends EventEmitter<TaskEvents> implements TaskLike {

 		}
 	}
 
+	/**
+	 * Handles the Ralph mode restart logic.
+	 * If Ralph mode is enabled and within limits, restarts the task.
+	 *
+	 * @param result Optional completion result to check for delimiter
+	 * @returns true if task was restarted, false otherwise
+	 */
+	public async handleRalphRestart(result?: string): Promise<boolean> {
+		const provider = this.providerRef.deref()
+		const state = await provider?.getState()
+		if (provider && state?.alwaysAllowRalph && state?.ralphEnabled) {
+			const delimiter = state.ralphCompletionDelimiter
+
+			// Check delimiter if configured and result is provided
+			if (result !== undefined && delimiter && delimiter.trim() !== "") {
+				if (result.indexOf(delimiter) !== -1) {
+					return false
+				}
+
+				const assistantMessages = this.apiConversationHistory.filter((m) => m.role === "assistant").slice(-5)
+
+				for (const m of assistantMessages) {
+					const content = typeof m.content === "string" ? m.content : JSON.stringify(m.content)
+					if (content.indexOf(delimiter) !== -1) {
+						return false
+					}
+				}
+			}
+
+			const loopLimit = state.ralphLoopLimit ?? 5
+			const currentLoopCount = this.metadata.ralphLoopCount ?? 0
+
+			if (loopLimit <= 0 || currentLoopCount + 1 < loopLimit) {
+				const firstPrompt = this.metadata.task
+				const images = this.metadata.images
+
+				if (state.ralphKeepCurrentTask) {
+					await this.abortTask()
+				} else {
+					await provider.deleteTaskWithId(this.taskId)
+				}
+
+				setTimeout(async () => {
+					try {
+						await provider.createTask(firstPrompt, images, undefined, {
+							ralphLoopCount: currentLoopCount + 1,
+							mode: this.metadata.mode,
+						})
+						await provider.postMessageToWebview({ type: "invoke", invoke: "newChat" })
+					} catch (error) {
+						console.error("[Task] Failed to restart task in Ralph mode:", error)
+					}
+				}, 1000)
+
+				return true
+			}
+		}
+		return false
+	}
+
+	/**
+	 * Handles the case where the mistake limit has been reached.
+	 * If Ralph mode is enabled and within limits, restarts the task.
+	 * Otherwise, asks the user for guidance.
+	 *
+	 * @param guidance Optional guidance text to show the user
+	 * @returns Object containing the user's response if Ralph restart didn't happen
+	 */
+	public async handleMistakeLimitReached(
+		guidance: string = t("common:errors.mistake_limit_guidance"),
+	): Promise<{ response: ClineAskResponse; text?: string; images?: string[] } | undefined> {
+		const restarted = await this.handleRalphRestart()
+		if (restarted) {
+			await this.say("error", "Mistake limit reached. Ralph mode is restarting the task...")
+			return undefined
+		}
+
+		return await this.ask("mistake_limit_reached", guidance)
+	}
+
 	public async recursivelyMakeClineRequests(
 		userContent: Anthropic.Messages.ContentBlockParam[],
 		includeFileDetails: boolean = false,

label export class Task extends EventEmitter<TaskEvents> implements TaskLike {

 					),
 				)
 
-				const { response, text, images } = await this.ask(
-					"mistake_limit_reached",
-					t("common:errors.mistake_limit_guidance"),
-				)
+				const result = await this.handleMistakeLimitReached()
+
+				if (!result) {
+					return true
+				}
+
+				const { response, text, images } = result
 
 				if (response === "messageResponse") {
 					currentUserContent.push(

file src/core/tools/AttemptCompletionTool.ts
label export class AttemptCompletionTool extends BaseTool<"attempt_completion"> {

 				}
 			}
 
+			const restarted = await task.handleRalphRestart(result)
+			if (restarted) {
+				return
+			}
+
 			// kilocode_change start - Pass completion suggestions based on task mode
 			const completionSuggestions = getCompletionSuggestions(task)
 			const completionAskText = completionSuggestions ? JSON.stringify({ suggest: completionSuggestions }) : ""

file src/core/webview/ClineProvider.ts
label export class ClineProvider

 			alwaysAllowWriteOutsideWorkspace,
 			alwaysAllowWriteProtected,
 			alwaysAllowDelete, // kilocode_change
+			alwaysAllowRalph,
 			alwaysAllowExecute,
 			allowedCommands,
 			deniedCommands,

label export class ClineProvider

 			yoloGatekeeperApiConfigId, // kilocode_change: AI gatekeeper for YOLO mode
 			selectedMicrophoneDevice, // kilocode_change: Selected microphone device for STT
 			isBrowserSessionActive,
+			ralphEnabled,
+			ralphLoopLimit,
+			ralphCompletionDelimiter,
+			ralphKeepCurrentTask,
 		} = await this.getState()
 
 		// kilocode_change start: Get active model for virtual quota fallback UI display

label export class ClineProvider

 			alwaysAllowWriteOutsideWorkspace: alwaysAllowWriteOutsideWorkspace ?? false,
 			alwaysAllowWriteProtected: alwaysAllowWriteProtected ?? false,
 			alwaysAllowDelete: alwaysAllowDelete ?? false, // kilocode_change
+			alwaysAllowRalph: alwaysAllowRalph ?? false,
 			alwaysAllowExecute: alwaysAllowExecute ?? false,
 			alwaysAllowBrowser: alwaysAllowBrowser ?? false,
 			alwaysAllowMcp: alwaysAllowMcp ?? false,

label export class ClineProvider

 				}
 			})(),
 			debug: vscode.workspace.getConfiguration(Package.name).get<boolean>("debug", false),
+			ralphEnabled: ralphEnabled ?? false,
+			ralphLoopLimit: ralphLoopLimit ?? 5,
+			ralphCompletionDelimiter: ralphCompletionDelimiter !== undefined ? ralphCompletionDelimiter : "<ralph>COMPLETED</ralph>",
+			ralphKeepCurrentTask: ralphKeepCurrentTask ?? true,
 		}
 	}
 

label export class ClineProvider

 			alwaysAllowWriteOutsideWorkspace: stateValues.alwaysAllowWriteOutsideWorkspace ?? false,
 			alwaysAllowWriteProtected: stateValues.alwaysAllowWriteProtected ?? false,
 			alwaysAllowDelete: stateValues.alwaysAllowDelete ?? false, // kilocode_change
+			alwaysAllowRalph: stateValues.alwaysAllowRalph ?? false,
 			alwaysAllowExecute: stateValues.alwaysAllowExecute ?? true,
 			alwaysAllowBrowser: stateValues.alwaysAllowBrowser ?? true,
 			alwaysAllowMcp: stateValues.alwaysAllowMcp ?? true,

label export class ClineProvider

 				}
 			})(),
 			appendSystemPrompt: stateValues.appendSystemPrompt, // kilocode_change: CLI append system prompt
+			ralphEnabled: stateValues.ralphEnabled ?? false,
+			ralphLoopLimit: stateValues.ralphLoopLimit ?? 5,
+			ralphCompletionDelimiter: stateValues.ralphCompletionDelimiter !== undefined ? stateValues.ralphCompletionDelimiter : "<ralph>COMPLETED</ralph>",
+			ralphKeepCurrentTask: stateValues.ralphKeepCurrentTask ?? true,
 		}
 	}
 

file src/core/webview/webviewMessageHandler.ts
label export const webviewMessageHandler = async (

 			await provider.postStateToWebview()
 			break
 		// kilocode_change end
+		case "ralphEnabled":
+			await updateGlobalState("ralphEnabled", message.bool ?? false)
+			await provider.postStateToWebview()
+			break
+		case "ralphLoopLimit":
+			await updateGlobalState("ralphLoopLimit", message.value ?? 5)
+			await provider.postStateToWebview()
+			break
+		case "ralphCompletionDelimiter":
+			await updateGlobalState("ralphCompletionDelimiter", message.text !== undefined ? message.text : "<ralph>COMPLETED</ralph>")
+			await provider.postStateToWebview()
+			break
+		case "ralphKeepCurrentTask":
+			await updateGlobalState("ralphKeepCurrentTask", message.bool ?? true)
+			await provider.postStateToWebview()
+			break
 		case "enhancePrompt":
 			if (message.text) {
 				try {

file webview-ui/src/components/chat/ChatTextArea.tsx
label import { KiloProfileSelector } from "../kilocode/chat/KiloProfileSelector"

 import { MAX_IMAGES_PER_MESSAGE } from "./ChatView"
 import ContextMenu from "./ContextMenu"
 import { ImageWarningBanner } from "./ImageWarningBanner"
-import { VolumeX, Pin, Check, WandSparkles, SendHorizontal, Paperclip, MessageSquareX } from "lucide-react"
+import { VolumeX, Pin, Check, WandSparkles, SendHorizontal, Paperclip, MessageSquareX, Infinity } from "lucide-react"
 import { IndexingStatusBadge } from "./IndexingStatusBadge"
 import { MicrophoneButton } from "./MicrophoneButton" // kilocode_change: STT microphone button
 import { VolumeVisualizer } from "./VolumeVisualizer" // kilocode_change: STT volume level visual

label export const ChatTextArea = forwardRef<HTMLTextAreaElement, ChatTextAreaProps>(

 			ghostServiceSettings, // kilocode_change
 			language, // User's VSCode display language
 			experiments, // kilocode_change: For speechToText experiment flag
+			ralphEnabled,
+			setRalphEnabled,
+			alwaysAllowRalph,
 		} = useExtensionState()
 
 		// kilocode_change start: Manage STT status and error state with auto-clearing

label export const ChatTextArea = forwardRef<HTMLTextAreaElement, ChatTextAreaProps>(

 									{/* kilocode_change end */}
 								</div>
 
+								{alwaysAllowRalph && (
+                  <StandardTooltip content={`Ralph Mode ${ralphEnabled ? "on" : "off"}`}>
+                    <button
+                      aria-label={`Ralph Mode ${ralphEnabled ? "on" : "off"}`}
+                      onClick={() => {
+                        const newValue = !ralphEnabled
+                        setRalphEnabled(newValue)
+                        vscode.postMessage({ type: "ralphEnabled", bool: newValue })
+                      }}
+                      className={cn(
+                        "relative inline-flex items-center justify-center",
+                        "bg-transparent border-none p-1.5",
+                        "rounded-md min-w-[28px] min-h-[28px]",
+                        "transition-all duration-150",
+                        "hover:bg-[rgba(255,255,255,0.03)] hover:border-[rgba(255,255,255,0.15)]",
+                        "focus:outline-none focus-visible:ring-1 focus-visible:ring-vscode-focusBorder",
+                        "active:bg-[rgba(255,255,255,0.1)]",
+                        "cursor-pointer",
+                        ralphEnabled
+                          ? "text-vscode-charts-orange opacity-100"
+                          : "text-vscode-descriptionForeground opacity-60 hover:opacity-100",
+                      )}>
+                      <Infinity className="w-4 h-4" />
+                    </button>
+                  </StandardTooltip>
+                )}
+
 								<KiloProfileSelector
 									currentConfigId={currentConfigId}
 									currentApiConfigName={currentApiConfigName}

file webview-ui/src/components/settings/AutoApproveSettings.tsx

 import { HTMLAttributes, useState } from "react"
-import { X } from "lucide-react"
+import { X, Infinity } from "lucide-react"
 import { Trans } from "react-i18next"
 import { Package } from "@roo/package"
 

label type AutoApproveSettingsProps = HTMLAttributes<HTMLDivElement> & {

 	alwaysAllowModeSwitch?: boolean
 	alwaysAllowSubtasks?: boolean

+	alwaysAllowRalph?: boolean
+	ralphLoopLimit?: number
+	ralphCompletionDelimiter?: string
+	ralphKeepCurrentTask?: boolean
 	alwaysAllowFollowupQuestions?: boolean
 	followupAutoApproveTimeoutMs?: number
 	allowedCommands?: string[]

label type AutoApproveSettingsProps = HTMLAttributes<HTMLDivElement> & {

 		| "alwaysAllowModeSwitch"
 		| "alwaysAllowSubtasks"

+		| "alwaysAllowRalph"
+		| "ralphLoopLimit"
+		| "ralphCompletionDelimiter"
+		| "ralphKeepCurrentTask"
 		| "alwaysAllowFollowupQuestions"
 		| "followupAutoApproveTimeoutMs"
 		| "allowedCommands"

label export const AutoApproveSettings = ({

 	alwaysAllowModeSwitch,
 	alwaysAllowSubtasks,

+	alwaysAllowRalph,
+	ralphLoopLimit,
+	ralphCompletionDelimiter,
+	ralphKeepCurrentTask,
 	alwaysAllowFollowupQuestions,
 	followupAutoApproveTimeoutMs = 60000,
 	allowedCommands,

label export const AutoApproveSettings = ({

 						alwaysAllowModeSwitch={alwaysAllowModeSwitch}
 						alwaysAllowSubtasks={alwaysAllowSubtasks}

+						alwaysAllowRalph={alwaysAllowRalph}
 						alwaysAllowFollowupQuestions={alwaysAllowFollowupQuestions}
 						onToggle={(key, value) => setCachedStateField(key, value)}
 					/>

label export const AutoApproveSettings = ({

 						</div>
 					</div>
 				)}
+
+				{alwaysAllowRalph && (
+					<div className="flex flex-col gap-3 pl-3 border-l-2 border-vscode-button-background mt-4">
+						<div className="flex items-center gap-4 font-bold">
+							<Infinity className="w-4 h-4" />
+							<div>Ralph</div>
+						</div>
+						<div className="flex flex-row gap-4 items-start mt-2">
+							<div className="flex-1">
+								<label className="block font-medium mb-1">
+									Loop Limit
+								</label>
+								<div className="flex items-center gap-2">
+									<Slider
+										min={0}
+										max={100}
+										step={1}
+										value={[ralphLoopLimit ?? 5]}
+										onValueChange={([value]) => setCachedStateField("ralphLoopLimit", value)}
+									/>
+									<span className="w-12 text-center font-bold">
+										{ralphLoopLimit === 0 ? "âˆž" : ralphLoopLimit}
+									</span>
+								</div>
+								<div className="text-vscode-descriptionForeground text-sm mt-1">
+									Maximum number of times Ralph will automatically restart the task. Set to 0 for unlimited loops
+								</div>
+							</div>
+							<div className="flex-1">
+								<label className="block font-medium mb-1">
+									Completion Delimiter
+								</label>
+								<Input
+									value={ralphCompletionDelimiter ?? ""}
+									onChange={(e: any) => setCachedStateField("ralphCompletionDelimiter", e.target.value)}
+									placeholder="e.g., <ralph>COMPLETED</ralph>"
+									className="w-full"
+								/>
+								<div className="text-vscode-descriptionForeground text-sm mt-1">
+									If this text is found in the completion result, Ralph will stop looping
+								</div>
+							</div>
+						</div>
+						<div className="mt-2">
+							<VSCodeCheckbox
+								checked={ralphKeepCurrentTask ?? true}
+								onChange={(e: any) => {
+									setCachedStateField("ralphKeepCurrentTask", e.target.checked)
+									vscode.postMessage({ type: "ralphKeepCurrentTask", bool: e.target.checked })
+								}}>
+								<span className="font-medium">Keep current task each loop</span>
+							</VSCodeCheckbox>
+							<div className="text-vscode-descriptionForeground text-sm mt-1 ml-6">
+								If enabled, Ralph will keep the current task as history
+							</div>
+						</div>
+					</div>
+				)}
 			</Section>
 
 			{/* kilocode_change start */}

file webview-ui/src/components/settings/AutoApproveToggle.tsx
label import type { GlobalSettings } from "@roo-code/types"

 
 import { useAppTranslation } from "@/i18n/TranslationContext"
 import { cn } from "@/lib/utils"
+import { Infinity } from "lucide-react"
 import { Button, StandardTooltip } from "@/components/ui"
 
 type AutoApproveToggles = Pick<
 	GlobalSettings,
 	| "alwaysAllowReadOnly"
 	| "alwaysAllowWrite"
 	| "alwaysAllowDelete" // kilocode_change
 	| "alwaysAllowBrowser"
 	| "alwaysAllowMcp"
 	| "alwaysAllowModeSwitch"
 	| "alwaysAllowSubtasks"

+	| "alwaysAllowRalph"
 	| "alwaysAllowFollowupQuestions"
 >
 

label export const autoApproveSettingsConfig: Record<AutoApproveSetting, AutoApproveCo

 		icon: "question",
 		testId: "always-allow-followup-questions-toggle",
 	},
+	alwaysAllowRalph: {
+		key: "alwaysAllowRalph",
+		labelKey: "Ralph",
+		descriptionKey: "Show Ralph button in chat mode that enable autonomous agent loop ability",
+		icon: "infinity",
+		testId: "always-allow-ralph-toggle",
+	},
 }
 
 type AutoApproveToggleProps = AutoApproveToggles & {

label export const AutoApproveToggle = ({ onToggle, ...props }: AutoApproveToggleProps

 						aria-pressed={!!props[key]}
 						data-testid={testId}
 						className={cn("gap-1.5 text-xs whitespace-nowrap", !props[key] && "opacity-50")}>
-						<span className={`codicon codicon-${icon} text-sm`} />
+						{icon === "infinity" ? (
+							<Infinity className="size-3.5" />
+						) : (
+							<span className={`codicon codicon-${icon} text-sm`} />
+						)}
 						<span>{t(labelKey)}</span>
 					</Button>
 				</StandardTooltip>

file webview-ui/src/components/settings/SettingsView.tsx
label const SettingsView = forwardRef<SettingsViewRef, SettingsViewProps>((props, ref)

 		language,
 		alwaysAllowBrowser,
 		alwaysAllowExecute,
+		alwaysAllowRalph,
+		ralphLoopLimit,
+		ralphCompletionDelimiter,
+		ralphKeepCurrentTask,
 		alwaysAllowMcp,
 		alwaysAllowModeSwitch,
 		alwaysAllowSubtasks,

label const SettingsView = forwardRef<SettingsViewRef, SettingsViewProps>((props, ref)

 					alwaysAllowWriteProtected: alwaysAllowWriteProtected ?? undefined,
 					alwaysAllowDelete: alwaysAllowDelete ?? undefined, // kilocode_change
 					alwaysAllowExecute: alwaysAllowExecute ?? undefined,
+					alwaysAllowRalph: alwaysAllowRalph ?? undefined,
+					ralphLoopLimit: ralphLoopLimit ?? 5,
+					ralphCompletionDelimiter: ralphCompletionDelimiter !== undefined ? ralphCompletionDelimiter : "<ralph>COMPLETED</ralph>",
+					ralphKeepCurrentTask: ralphKeepCurrentTask ?? true,
 					alwaysAllowBrowser: alwaysAllowBrowser ?? undefined,
 					alwaysAllowMcp,
 					alwaysAllowModeSwitch,

label const SettingsView = forwardRef<SettingsViewRef, SettingsViewProps>((props, ref)

 								alwaysAllowDelete={alwaysAllowDelete} // kilocode_change
 								alwaysAllowBrowser={alwaysAllowBrowser}
 								alwaysAllowMcp={alwaysAllowMcp}
+							  alwaysAllowRalph={alwaysAllowRalph}
+							  ralphLoopLimit={ralphLoopLimit}
+							  ralphCompletionDelimiter={ralphCompletionDelimiter}
+							  ralphKeepCurrentTask={ralphKeepCurrentTask}
 								alwaysAllowModeSwitch={alwaysAllowModeSwitch}
 								alwaysAllowSubtasks={alwaysAllowSubtasks}

file webview-ui/src/components/settings/__tests__/AutoApproveToggle.spec.tsx
label describe("AutoApproveToggle", () => {

 		alwaysAllowReadOnly: true,
 		alwaysAllowWrite: false,
 		alwaysAllowDelete: false, // kilocode_change
+    alwaysAllowRalph: false,
 		alwaysAllowBrowser: false,
 		alwaysAllowMcp: false,
 		alwaysAllowModeSwitch: true,

file webview-ui/src/context/ExtensionStateContext.tsx
label export interface ExtensionStateContextType extends ExtensionState {

 	dismissedNotificationIds: string[] // kilocode_change
 	yoloMode?: boolean // kilocode_change
 	setYoloMode: (value: boolean) => void // kilocode_Change
+	ralphEnabled?: boolean
+	setRalphEnabled: (value: boolean) => void
 	// kilocode_change start - Auto-purge settings
 	autoPurgeEnabled?: boolean
 	setAutoPurgeEnabled: (value: boolean) => void

label export interface ExtensionStateContextType extends ExtensionState {

 	setAlwaysAllowWriteOutsideWorkspace: (value: boolean) => void
 	setAlwaysAllowDelete: (value: boolean) => void // kilocode_change
 	setAlwaysAllowExecute: (value: boolean) => void
+	alwaysAllowRalph?: boolean
+	setAlwaysAllowRalph: (value: boolean) => void
 	setAlwaysAllowBrowser: (value: boolean) => void
 	setAlwaysAllowMcp: (value: boolean) => void
 	setAlwaysAllowModeSwitch: (value: boolean) => void

label export const ExtensionStateContextProvider: React.FC<{ children: React.ReactNode

 		customCondensingPrompt: "", // Default empty string for custom condensing prompt
 		yoloGatekeeperApiConfigId: "", // kilocode_change: Default empty string for gatekeeper API config ID
 		hasOpenedModeSelector: false, // Default to false (not opened yet)
+		ralphEnabled: false,
 		hasCompletedOnboarding: undefined, // kilocode_change: Leave unset until extension sends value
 		autoApprovalEnabled: true,
 		customModes: [],

label export const ExtensionStateContextProvider: React.FC<{ children: React.ReactNode

 			setState((prevState) => ({ ...prevState, alwaysAllowWriteOutsideWorkspace: value })),
 		setAlwaysAllowDelete: (value) => setState((prevState) => ({ ...prevState, alwaysAllowDelete: value })), // kilocode_change
 		setAlwaysAllowExecute: (value) => setState((prevState) => ({ ...prevState, alwaysAllowExecute: value })),
+		setAlwaysAllowRalph: (value) => setState((prevState) => ({ ...prevState, alwaysAllowRalph: value })),
 		setAlwaysAllowBrowser: (value) => setState((prevState) => ({ ...prevState, alwaysAllowBrowser: value })),
 		setAlwaysAllowMcp: (value) => setState((prevState) => ({ ...prevState, alwaysAllowMcp: value })),
 		setAlwaysAllowModeSwitch: (value) => setState((prevState) => ({ ...prevState, alwaysAllowModeSwitch: value })),

label export const ExtensionStateContextProvider: React.FC<{ children: React.ReactNode

 		setShowTimestamps: (value) => setState((prevState) => ({ ...prevState, showTimestamps: value })),
 		setShowDiffStats: (value) => setState((prevState) => ({ ...prevState, showDiffStats: value })), // kilocode_change
 		setYoloMode: (value) => setState((prevState) => ({ ...prevState, yoloMode: value })), // kilocode_change
+		setRalphEnabled: (value) => setState((prevState) => ({ ...prevState, ralphEnabled: value })),
 		// kilocode_change end
 		setAutoApprovalEnabled: (value) => setState((prevState) => ({ ...prevState, autoApprovalEnabled: value })),
 		setCustomModes: (value) => setState((prevState) => ({ ...prevState, customModes: value })),

file webview-ui/src/hooks/useAutoApprovalToggles.ts
label export function useAutoApprovalToggles() {

 		alwaysAllowMcp,
 		alwaysAllowModeSwitch,
 		alwaysAllowSubtasks,
+		alwaysAllowRalph,
 		alwaysAllowFollowupQuestions,

 
 	const toggles = useMemo(
 		() => ({
 			alwaysAllowReadOnly,
 			alwaysAllowWrite,
 			alwaysAllowDelete, // kilocode_change
 			alwaysAllowExecute,
 			alwaysAllowBrowser,
 			alwaysAllowMcp,
 			alwaysAllowModeSwitch,
 			alwaysAllowSubtasks,
+			alwaysAllowRalph,
 			alwaysAllowFollowupQuestions,

 		[
 			alwaysAllowReadOnly,
 			alwaysAllowWrite,
 			alwaysAllowDelete, // kilocode_change
 			alwaysAllowExecute,
 			alwaysAllowBrowser,
 			alwaysAllowMcp,
 			alwaysAllowModeSwitch,
 			alwaysAllowSubtasks,
+			alwaysAllowRalph,
 			alwaysAllowFollowupQuestions,

 	)
