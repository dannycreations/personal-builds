file packages/types/src/global-settings.ts
label export const globalSettingsSchema = z.object({

 	alwaysAllowDelete: z.boolean().optional(), // kilocode_change
 	writeDelayMs: z.number().min(0).optional(),
 	alwaysAllowBrowser: z.boolean().optional(),
+	alwaysApproveResubmit: z.boolean().optional(),
 	requestDelaySeconds: z.number().optional(),
+	requestRetryMax: z.number().min(0).optional(),
 	alwaysAllowMcp: z.boolean().optional(),
 	alwaysAllowModeSwitch: z.boolean().optional(),
 	alwaysAllowSubtasks: z.boolean().optional(),

label export const EVALS_SETTINGS: RooCodeSettings = {

 	alwaysAllowDelete: true, // kilocode_change
 	writeDelayMs: 1000,
 	alwaysAllowBrowser: true,
+	alwaysApproveResubmit: true,
 	requestDelaySeconds: 10,
+	requestRetryMax: 0,
 	alwaysAllowMcp: true,
 	alwaysAllowModeSwitch: true,
 	alwaysAllowSubtasks: true,

file packages/types/src/vscode-extension-host.ts
label export type ExtensionState = Pick<

 	| "alwaysAllowModeSwitch"
 	| "alwaysAllowSubtasks"
 	| "alwaysAllowFollowupQuestions"
+	| "alwaysApproveResubmit"
 	| "alwaysAllowExecute"
 	| "followupAutoApproveTimeoutMs"
 	| "allowedCommands"

label export type ExtensionState = Pick<

 	| "includeCurrentCost"
 	| "maxGitStatusFiles"
 	| "requestDelaySeconds"
+	| "requestRetryMax"
 	| "selectedMicrophoneDevice" // kilocode_change: Selected microphone device for STT
 > & {
 	version: string

file src/core/auto-approval/index.ts
label export type AutoApprovalState =

 	| "alwaysAllowSubtasks"
 	| "alwaysAllowExecute"
 	| "alwaysAllowFollowupQuestions"
+	| "alwaysApproveResubmit"
 
 // Some of these actions have additional settings associated with them.
 export type AutoApprovalStateOptions =

file src/core/task/Task.ts
label import { MessageManager } from "../message-manager"

 import { validateAndFixToolResultIds } from "./validateToolResultIds"
 import { deduplicateToolUseBlocks } from "./deduplicateToolUseBlocks"
 
-const MAX_EXPONENTIAL_BACKOFF_SECONDS = 600 // 10 minutes
 const DEFAULT_USAGE_COLLECTION_TIMEOUT_MS = 5000 // 5 seconds
 const FORCED_CONTEXT_REDUCTION_PERCENT = 75 // Keep 75% of context (remove 25%) on context window errors
 const MAX_CONTEXT_WINDOW_RETRIES = 3 // Maximum retries for context window errors

label export class Task extends EventEmitter<TaskEvents> implements TaskLike {

 								`[Task#${this.taskId}.${this.instanceId}] Stream failed, will retry: ${streamingFailedMessage}`,
 							)
 
-							// Apply exponential backoff similar to first-chunk errors when auto-resubmit is enabled
+							// Apply backoff similar to first-chunk errors when auto-resubmit is enabled
 							const stateForBackoff = await this.providerRef.deref()?.getState()
-							if (stateForBackoff?.autoApprovalEnabled) {
+							const retryMax = stateForBackoff?.requestRetryMax ?? 0
+							if (
+								stateForBackoff?.autoApprovalEnabled &&
+								stateForBackoff?.alwaysApproveResubmit &&
+								(retryMax === 0 || (currentItem.retryAttempt ?? 0) < retryMax)
+							) {
 								await this.backoffAndAnnounce(currentItem.retryAttempt ?? 0, error)
 
 								// Check if task was aborted during the backoff
 								if (this.abort) {
 									console.log(
 										`[Task#${this.taskId}.${this.instanceId}] Task aborted during mid-stream retry backoff`,
 									)
 									// Abort the entire task
 									this.abortReason = "user_cancelled"
 									await this.abortTask()
 									break
 								}
-							}
 
-							// Push the same content back onto the stack to retry, incrementing the retry attempt counter
-							stack.push({
-								userContent: currentUserContent,
-								includeFileDetails: false,
-								retryAttempt: (currentItem.retryAttempt ?? 0) + 1,
-							})
+								// Push the same content back onto the stack to retry, incrementing the retry attempt counter
+								stack.push({
+									userContent: currentUserContent,
+									includeFileDetails: false,
+									retryAttempt: (currentItem.retryAttempt ?? 0) + 1,
+								})
 
-							// Continue to retry the request
-							continue
+								// Continue to retry the request
+								continue
+							} else {
+								// Prompt the user for retry decision if auto-resubmit is disabled or retry limit reached
+								const { response } = await this.ask(
+									"api_req_failed",
+									streamingFailedMessage ||
+										error.message ||
+										"The stream was terminated unexpectedly.",
+								)
+
+								if (response === "yesButtonClicked") {
+									await this.say("api_req_retried")
+
+									// Push the same content back to retry
+									stack.push({
+										userContent: currentUserContent,
+										includeFileDetails: false,
+										retryAttempt: (currentItem.retryAttempt ?? 0) + 1,
+									})
+
+									// Continue to retry the request
+									continue
+								} else {
+									// User declined to retry or task was aborted - fail the task
+									await this.say(
+										"error",
+										streamingFailedMessage ||
+											error.message ||
+											"The stream was terminated unexpectedly and the user declined to retry.",
+									)
+
+									await this.addToApiConversationHistory({
+										role: "assistant",
+										content: [
+											{
+												type: "text",
+												text: `Failure: The stream was terminated unexpectedly: ${streamingFailedMessage || error.message || "Unknown error"}`,
+											},
+										],
+									})
+
+									// End this iteration of recursivelyMakeClineRequests
+									return true
+								}
+							}
 						}
 					}
 				} finally {

label export class Task extends EventEmitter<TaskEvents> implements TaskLike {

 
 					// Check if we should auto-retry or prompt the user
 					// Reuse the state variable from above
-					if (state?.autoApprovalEnabled) {
+					const retryMax = state?.requestRetryMax ?? 0
+					if (
+						state?.autoApprovalEnabled &&
+						state?.alwaysApproveResubmit &&
+						(retryMax === 0 || (currentItem.retryAttempt ?? 0) < retryMax)
+					) {
 						// Auto-retry with backoff - don't persist failure message when retrying
 						await this.backoffAndAnnounce(
 							currentItem.retryAttempt ?? 0,

label export class Task extends EventEmitter<TaskEvents> implements TaskLike {

 			}
 			// kilocode_change end
 			// note that this api_req_failed ask is unique in that we only present this option if the api hasn't streamed any content yet (ie it fails on the first chunk due), as it would allow them to hit a retry button. However if the api failed mid-stream, it could be in any arbitrary state where some tools may have executed, so that error is handled differently and requires cancelling the task entirely.
-			if (autoApprovalEnabled) {
-				// Apply shared exponential backoff and countdown UX
+			const retryMax = state?.requestRetryMax ?? 0
+			if (autoApprovalEnabled && state?.alwaysApproveResubmit && (retryMax === 0 || retryAttempt < retryMax)) {
+				// Apply shared backoff and countdown UX
 				await this.backoffAndAnnounce(retryAttempt, error)
 
 				// CRITICAL: Check if task was aborted during the backoff countdown

label export class Task extends EventEmitter<TaskEvents> implements TaskLike {

 	private async backoffAndAnnounce(retryAttempt: number, error: any): Promise<void> {
 		try {
 			const state = await this.providerRef.deref()?.getState()
-			const baseDelay = state?.requestDelaySeconds || 5
-
-			let exponentialDelay = Math.min(
-				Math.ceil(baseDelay * Math.pow(2, retryAttempt)),
-				MAX_EXPONENTIAL_BACKOFF_SECONDS,
-			)
-
-			// Respect provider rate limit window
-			let rateLimitDelay = 0
-			const rateLimit = (state?.apiConfiguration ?? this.apiConfiguration)?.rateLimitSeconds || 0
-			if (Task.lastGlobalApiRequestTime && rateLimit > 0) {
-				const elapsed = performance.now() - Task.lastGlobalApiRequestTime
-				rateLimitDelay = Math.ceil(Math.min(rateLimit, Math.max(0, rateLimit * 1000 - elapsed) / 1000))
-			}
+			let requestDelaySeconds = state?.requestDelaySeconds ?? 10
 
 			// Prefer RetryInfo on 429 if present
 			if (error?.status === 429) {
 				const retryInfo = error?.errorDetails?.find(
 					(d: any) => d["@type"] === "type.googleapis.com/google.rpc.RetryInfo",
 				)
 				const match = retryInfo?.retryDelay?.match?.(/^(\d+)s$/)
 				if (match) {
-					exponentialDelay = Number(match[1]) + 1
+					requestDelaySeconds = Number(match[1]) + 1
 				}
 			}
 
-			const finalDelay = Math.max(exponentialDelay, rateLimitDelay)
-			if (finalDelay <= 0) {
-				return
-			}
-
 			// Build header text; fall back to error message if none provided
 			let headerText
 			if (error.status) {
 				// Include both status code (for ChatRow parsing) and detailed message (for error details)
 				// Format: "<status>\n<message>" allows ChatRow to extract status via parseInt(text.substring(0,3))
 				// while preserving the full error message in errorDetails for debugging
 				const errorMessage = error?.message || "Unknown error"
 				headerText = `${error.status}\n${errorMessage}`
 			} else if (error?.message) {
 				headerText = error.message
 			} else {
 				headerText = "Unknown error"
 			}
 
 			headerText = headerText ? `${headerText}\n` : ""
 
-			// Show countdown timer with exponential backoff
-			for (let i = finalDelay; i > 0; i--) {
+			for (let i = requestDelaySeconds; i > 0; i--) {
 				// Check abort flag during countdown to allow early exit
 				if (this.abort) {
 					throw new Error(`[Task#${this.taskId}] Aborted during retry countdown`)

file src/core/webview/ClineProvider.ts
label export class ClineProvider

 			enhancementApiConfigId,
 			commitMessageApiConfigId, // kilocode_change
 			terminalCommandApiConfigId, // kilocode_change
+			requestRetryMax,
 			autoApprovalEnabled,
 			customModes,
 			experiments,

label export class ClineProvider

 			dismissedNotificationIds, // kilocode_change
 			morphApiKey, // kilocode_change
 			fastApplyModel, // kilocode_change: Fast Apply model selection
+			alwaysApproveResubmit,
 			fastApplyApiProvider, // kilocode_change: Fast Apply model api base url
 			alwaysAllowFollowupQuestions,
 			followupAutoApproveTimeoutMs,

label export class ClineProvider

 			alwaysAllowMcp: alwaysAllowMcp ?? false,
 			alwaysAllowModeSwitch: alwaysAllowModeSwitch ?? false,
 			alwaysAllowSubtasks: alwaysAllowSubtasks ?? false,
+			alwaysApproveResubmit: alwaysApproveResubmit ?? true,
 			isBrowserSessionActive,
 			yoloMode: yoloMode ?? false, // kilocode_change
 			allowedMaxRequests,

label export class ClineProvider

 			includeCurrentTime: includeCurrentTime ?? true,
 			includeCurrentCost: includeCurrentCost ?? true,
 			maxGitStatusFiles: maxGitStatusFiles ?? 0,
+			requestDelaySeconds: requestDelaySeconds ?? 10,
+			requestRetryMax: requestRetryMax ?? 0,
 			taskSyncEnabled,
 			remoteControlEnabled,
 			imageGenerationProvider,

label export class ClineProvider

 			alwaysAllowModeSwitch: stateValues.alwaysAllowModeSwitch ?? true,
 			alwaysAllowSubtasks: stateValues.alwaysAllowSubtasks ?? true,
 			alwaysAllowFollowupQuestions: stateValues.alwaysAllowFollowupQuestions ?? false,
+			alwaysApproveResubmit: stateValues.alwaysApproveResubmit ?? true,
+			requestDelaySeconds: stateValues.requestDelaySeconds ?? 10,
+			requestRetryMax: stateValues.requestRetryMax ?? 0,
 			isBrowserSessionActive,
 			yoloMode: stateValues.yoloMode ?? false, // kilocode_change
 			followupAutoApproveTimeoutMs: stateValues.followupAutoApproveTimeoutMs ?? 60000,

file src/core/webview/webviewMessageHandler.ts
label export const webviewMessageHandler = async (

 						if (!value) {
 							continue
 						}
+					} else if (
+						key === "alwaysApproveResubmit" ||
+						key === "requestRetryMax" ||
+						key === "requestDelaySeconds"
+					) {
+						newValue = value
 					}
 
 					await provider.contextProxy.setValue(key as keyof RooCodeSettings, newValue)

file webview-ui/src/components/settings/AutoApproveSettings.tsx
label type AutoApproveSettingsProps = HTMLAttributes<HTMLDivElement> & {

 	alwaysAllowMcp?: boolean
 	alwaysAllowModeSwitch?: boolean
 	alwaysAllowSubtasks?: boolean
+	alwaysApproveResubmit?: boolean
 	alwaysAllowExecute?: boolean
 	alwaysAllowFollowupQuestions?: boolean
 	followupAutoApproveTimeoutMs?: number

label type AutoApproveSettingsProps = HTMLAttributes<HTMLDivElement> & {

 		| "alwaysAllowMcp"
 		| "alwaysAllowModeSwitch"
 		| "alwaysAllowSubtasks"
+		| "alwaysApproveResubmit"
 		| "alwaysAllowExecute"
 		| "alwaysAllowFollowupQuestions"
 		| "followupAutoApproveTimeoutMs"

label export const AutoApproveSettings = ({

 	const { t } = useAppTranslation()
 	const [commandInput, setCommandInput] = useState("")
 	const [deniedCommandInput, setDeniedCommandInput] = useState("")
-	const { autoApprovalEnabled, setAutoApprovalEnabled, listApiConfigMeta } = useExtensionState() // kilocode_change: Add listApiConfigMeta for gatekeeper
+	const {
+		autoApprovalEnabled,
+		setAutoApprovalEnabled,
+		listApiConfigMeta,
+		alwaysApproveResubmit,
+		requestDelaySeconds,
+		requestRetryMax,
+		setRequestRetryMax,
+		setRequestDelaySeconds,
+	} = useExtensionState() // kilocode_change: Add listApiConfigMeta for gatekeeper
 
 	const toggles = useAutoApprovalToggles()
 

label export const AutoApproveSettings = ({

 						alwaysAllowMcp={alwaysAllowMcp}
 						alwaysAllowModeSwitch={alwaysAllowModeSwitch}
 						alwaysAllowSubtasks={alwaysAllowSubtasks}
+						alwaysApproveResubmit={alwaysApproveResubmit}
 						alwaysAllowExecute={alwaysAllowExecute}
 						alwaysAllowFollowupQuestions={alwaysAllowFollowupQuestions}
 						onToggle={(key, value) => setCachedStateField(key, value)}

label export const AutoApproveSettings = ({

 					</div>
 				)}
 
+				{alwaysApproveResubmit && (
+					<div className="flex flex-col gap-3 pl-3 border-l-2 border-vscode-button-background">
+						<div className="flex items-center gap-4 font-bold">
+							<span className="codicon codicon-refresh" />
+							<div>Retry</div>
+						</div>
+						<div className="space-y-4">
+							<div className="flex gap-4">
+								<div className="flex-1">
+									<div className="flex items-center gap-2">
+										<Slider
+											min={1}
+											max={60}
+											step={1}
+											className="grow"
+											value={[requestDelaySeconds ?? 10]}
+											onValueChange={([value]) => {
+												setRequestDelaySeconds(value)
+												vscode.postMessage({
+													type: "updateSettings",
+													updatedSettings: { requestDelaySeconds: value },
+												})
+											}}
+										/>
+										<span className="w-12 text-right">{requestDelaySeconds ?? 10}s</span>
+									</div>
+									<div className="text-vscode-descriptionForeground text-sm mt-1">
+										Base delay between retries (seconds)
+									</div>
+								</div>
+								<div className="flex-1">
+									<div className="flex items-center gap-2">
+										<Slider
+											min={0}
+											max={100}
+											step={1}
+											className="grow"
+											value={[requestRetryMax ?? 0]}
+											onValueChange={([value]) => {
+												setRequestRetryMax(value)
+												vscode.postMessage({
+													type: "updateSettings",
+													updatedSettings: { requestRetryMax: value },
+												})
+											}}
+										/>
+										<span className="w-12 text-right">
+											{requestRetryMax === 0 || requestRetryMax === undefined
+												? "âˆž"
+												: requestRetryMax}
+										</span>
+									</div>
+									<div className="text-vscode-descriptionForeground text-sm mt-1">
+										Maximum auto-retries for API requests
+									</div>
+								</div>
+							</div>
+						</div>
+					</div>
+				)}
+
 				{alwaysAllowExecute && (
 					<div className="flex flex-col gap-3 pl-3 border-l-2 border-vscode-button-background">
 						<div className="flex items-center gap-4 font-bold">

file webview-ui/src/components/settings/AutoApproveToggle.tsx
label type AutoApproveToggles = Pick<

 	| "alwaysAllowMcp"
 	| "alwaysAllowModeSwitch"
 	| "alwaysAllowSubtasks"
+	| "alwaysApproveResubmit"
 	| "alwaysAllowExecute"
 	| "alwaysAllowFollowupQuestions"
 >

label export const autoApproveSettingsConfig: Record<AutoApproveSetting, AutoApproveCo

 		icon: "list-tree",
 		testId: "always-allow-subtasks-toggle",
 	},
+	alwaysApproveResubmit: {
+		key: "alwaysApproveResubmit",
+		labelKey: "Retry",
+		descriptionKey: "Automatically retry requests when the model fails to provide a response or when a rate limit is reached",
+		icon: "refresh",
+		testId: "always-approve-resubmit-toggle",
+	},
 	alwaysAllowExecute: {
 		key: "alwaysAllowExecute",
 		labelKey: "settings:autoApprove.execute.label",

file webview-ui/src/components/settings/SettingsView.tsx
label const SettingsView = forwardRef<SettingsViewRef, SettingsViewProps>((props, ref)

 		alwaysAllowMcp,
 		alwaysAllowModeSwitch,
 		alwaysAllowSubtasks,
+		alwaysApproveResubmit,
+		requestDelaySeconds,
+		requestRetryMax,
 		alwaysAllowWrite,
 		alwaysAllowWriteOutsideWorkspace,
 		alwaysAllowWriteProtected,

label const SettingsView = forwardRef<SettingsViewRef, SettingsViewProps>((props, ref)

 					alwaysAllowBrowser: alwaysAllowBrowser ?? undefined,
 					alwaysAllowMcp,
 					alwaysAllowModeSwitch,
+					alwaysApproveResubmit,
+					requestDelaySeconds,
+					requestRetryMax,
 					allowedCommands: allowedCommands ?? [],
 					deniedCommands: deniedCommands ?? [],
 					// Note that we use `null` instead of `undefined` since `JSON.stringify`

label const SettingsView = forwardRef<SettingsViewRef, SettingsViewProps>((props, ref)

 								alwaysAllowMcp={alwaysAllowMcp}
 								alwaysAllowModeSwitch={alwaysAllowModeSwitch}
 								alwaysAllowSubtasks={alwaysAllowSubtasks}
+								alwaysApproveResubmit={alwaysApproveResubmit}
 								alwaysAllowExecute={alwaysAllowExecute}
 								alwaysAllowFollowupQuestions={alwaysAllowFollowupQuestions}
 								followupAutoApproveTimeoutMs={followupAutoApproveTimeoutMs}

file webview-ui/src/components/settings/__tests__/AutoApproveToggle.spec.tsx
label describe("AutoApproveToggle", () => {

 		alwaysAllowMcp: false,
 		alwaysAllowModeSwitch: true,
 		alwaysAllowSubtasks: false,
+		alwaysApproveResubmit: false,
 		alwaysAllowExecute: true,
 		alwaysAllowFollowupQuestions: false,
 		onToggle: mockOnToggle,

file webview-ui/src/context/ExtensionStateContext.tsx
label export interface ExtensionStateContextType extends ExtensionState {

 	setShowDiffStats: (value: boolean) => void // kilocode_change
 	hideCostBelowThreshold?: number // kilocode_change
 	setHideCostBelowThreshold: (value: number) => void // kilocode_change
+	requestRetryMax?: number
+	setRequestRetryMax: (value: number) => void
 	hoveringTaskTimeline?: boolean // kilocode_change
 	setHoveringTaskTimeline: (value: boolean) => void // kilocode_change
 	systemNotificationsEnabled?: boolean // kilocode_change

label export interface ExtensionStateContextType extends ExtensionState {

 	setAlwaysAllowMcp: (value: boolean) => void
 	setAlwaysAllowModeSwitch: (value: boolean) => void
 	setAlwaysAllowSubtasks: (value: boolean) => void
+	alwaysApproveResubmit: boolean
+	setAlwaysApproveResubmit: (value: boolean) => void
 	setBrowserToolEnabled: (value: boolean) => void
 	setShowRooIgnoredFiles: (value: boolean) => void
 	setShowAutoApproveMenu: (value: boolean) => void // kilocode_change
 	setEnableSubfolderRules: (value: boolean) => void
 	setShowAnnouncement: (value: boolean) => void
 	setAllowedCommands: (value: string[]) => void
 	setDeniedCommands: (value: string[]) => void
 	setAllowedMaxRequests: (value: number | undefined) => void
 	setAllowedMaxCost: (value: number | undefined) => void
+	setRequestDelaySeconds: (value: number) => void
 	setSoundEnabled: (value: boolean) => void
 	setSoundVolume: (value: number) => void
 	terminalShellIntegrationTimeout?: number

label export const ExtensionStateContextProvider: React.FC<{ children: React.ReactNode

 		alwaysAllowWrite: true, // kilocode_change
 		alwaysAllowReadOnly: true, // kilocode_change
 		alwaysAllowDelete: false, // kilocode_change
-		requestDelaySeconds: 5,
+		alwaysApproveResubmit: true,
+		requestDelaySeconds: 10,
+		requestRetryMax: 0,
 		currentApiConfigName: "default",
 		listApiConfigMeta: [],
 		mode: defaultModeSlug,

label export const ExtensionStateContextProvider: React.FC<{ children: React.ReactNode

 	const [includeCurrentTime, setIncludeCurrentTime] = useState(true)
 	const [includeCurrentCost, setIncludeCurrentCost] = useState(true)
 
+	const [alwaysApproveResubmit, setAlwaysApproveResubmit] = useState(true)
+	const [requestDelaySeconds, setRequestDelaySeconds] = useState(10)
+	const [requestRetryMax, setRequestRetryMax] = useState(0)
+
 	const setListApiConfigMeta = useCallback(
 		(value: ProviderSettingsEntry[]) => setState((prevState) => ({ ...prevState, listApiConfigMeta: value })),
 		[],

label export const ExtensionStateContextProvider: React.FC<{ children: React.ReactNode

 					if ((newState as any).includeCurrentCost !== undefined) {
 						setIncludeCurrentCost((newState as any).includeCurrentCost)
 					}
+					if (newState.alwaysApproveResubmit !== undefined) {
+						setAlwaysApproveResubmit(newState.alwaysApproveResubmit)
+					}
+					if (newState.requestDelaySeconds !== undefined) {
+						setRequestDelaySeconds(newState.requestDelaySeconds)
+					}
+					if (newState.requestRetryMax !== undefined) {
+						setRequestRetryMax(newState.requestRetryMax)
+					}
 					// Handle marketplace data if present in state message
 					if (newState.marketplaceItems !== undefined) {
 						setMarketplaceItems(newState.marketplaceItems)

label export const ExtensionStateContextProvider: React.FC<{ children: React.ReactNode

 		setAlwaysAllowMcp: (value) => setState((prevState) => ({ ...prevState, alwaysAllowMcp: value })),
 		setAlwaysAllowModeSwitch: (value) => setState((prevState) => ({ ...prevState, alwaysAllowModeSwitch: value })),
 		setAlwaysAllowSubtasks: (value) => setState((prevState) => ({ ...prevState, alwaysAllowSubtasks: value })),
+		alwaysApproveResubmit,
+		setAlwaysApproveResubmit,
 		setAlwaysAllowFollowupQuestions,
 		setFollowupAutoApproveTimeoutMs: (value) =>
 			setState((prevState) => ({ ...prevState, followupAutoApproveTimeoutMs: value })),
 		setShowAnnouncement: (value) => setState((prevState) => ({ ...prevState, shouldShowAnnouncement: value })),
 		setAllowedCommands: (value) => setState((prevState) => ({ ...prevState, allowedCommands: value })),
 		setDeniedCommands: (value) => setState((prevState) => ({ ...prevState, deniedCommands: value })),
 		setAllowedMaxRequests: (value) => setState((prevState) => ({ ...prevState, allowedMaxRequests: value })),
 		setAllowedMaxCost: (value) => setState((prevState) => ({ ...prevState, allowedMaxCost: value })),
+		requestDelaySeconds,
+		setRequestDelaySeconds,
 		setSoundEnabled: (value) => setState((prevState) => ({ ...prevState, soundEnabled: value })),
 		setSoundVolume: (value) => setState((prevState) => ({ ...prevState, soundVolume: value })),
 		setTtsEnabled: (value) => setState((prevState) => ({ ...prevState, ttsEnabled: value })),

label export const ExtensionStateContextProvider: React.FC<{ children: React.ReactNode

 		setSendMessageOnEnter: (value) => setState((prevState) => ({ ...prevState, sendMessageOnEnter: value })), // kilocode_change
 		setHideCostBelowThreshold: (value) =>
 			setState((prevState) => ({ ...prevState, hideCostBelowThreshold: value })),
+		requestRetryMax,
+		setRequestRetryMax,
 		setHoveringTaskTimeline: (value) => setState((prevState) => ({ ...prevState, hoveringTaskTimeline: value })),
 		setShowTimestamps: (value) => setState((prevState) => ({ ...prevState, showTimestamps: value })),
 		setShowDiffStats: (value) => setState((prevState) => ({ ...prevState, showDiffStats: value })), // kilocode_change

file webview-ui/src/hooks/useAutoApprovalToggles.ts
label export function useAutoApprovalToggles() {

 		alwaysAllowModeSwitch,
 		alwaysAllowSubtasks,
 		alwaysAllowFollowupQuestions,
+		alwaysApproveResubmit,
 	} = useExtensionState()
 
 	const toggles = useMemo(
 		() => ({
 			alwaysAllowReadOnly,
 			alwaysAllowWrite,
 			alwaysAllowDelete, // kilocode_change
 			alwaysAllowExecute,
 			alwaysAllowBrowser,
 			alwaysAllowMcp,
 			alwaysAllowModeSwitch,
 			alwaysAllowSubtasks,
 			alwaysAllowFollowupQuestions,
+			alwaysApproveResubmit,
 		}),
 		[
 			alwaysAllowReadOnly,
 			alwaysAllowWrite,
 			alwaysAllowDelete, // kilocode_change
 			alwaysAllowExecute,
 			alwaysAllowBrowser,
 			alwaysAllowMcp,
 			alwaysAllowModeSwitch,
 			alwaysAllowSubtasks,
 			alwaysAllowFollowupQuestions,
+			alwaysApproveResubmit,
 		],
 	)
 
